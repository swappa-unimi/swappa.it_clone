<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Riassunto Dispense</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='TettyRiassunto.html' title='Riassunto Dispense'>Riassunto Dispense</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
<a name='top' id='top'></a>
</p><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: Riassunto Dispense ::</strong>
</pre><p class='vspace'>Un riassunto delle dispense con solo le risposte alle domande che ho trovato fin'ora negli svariati tentativi di superare l'esame e/o nel simulatore. (Forse più, forse meno, forse uguale a quanto scritto in rosso nei vari capitoli delle dispense presenti <a class='wikilink' href='ProgrammazioneElaboratori.html'>qui</a>. In ogni caso tutto quello che c'è da sapere in unica pagina)
</p><hr />
<p><br clear='all' />
</p><div  style='text-align: left; background-color: #f5f9fc; width: 215px; border: 2px solid #cccccc; padding: 5px;' > 
<p  style='text-align: center;'><strong>Indice</strong>
</p><ol><li><a href='#c0'>Capitolo 1</a>
</li><li><a href='#c1'>Capitolo 2</a>
</li><li><a href='#c2'>Capitolo 3</a>
</li><li><a href='#c3'>Capitolo 4</a>
</li></ol></div>
<div class='vspace'></div><hr />
<p><a name='c0' id='c0'></a>
</p><h3>Capitolo 1</h3>
<h4>FBF</h4>
<p>Una proposizione è una frase di senso compiuto che può essere vera o falsa.
Il valore di verità di una fbf (formula ben formata),che può essere calcolato utilizzando le tabelle di verità, dipende dai valori di verità delle proposizioni che la compongono. <br />Interpretazione nella logica proposizionale: assegnamento dei valori di verità ad ogni proposizione atomica. <br />Una fbf può essere:
</p><ul><li>valida: se e solo se è vera per qualsiasi interpretazione (tautologia)
</li><li>soddisfacibile: se e solo se esiste almeno un'interpretazione per cui è essa è vera
</li></ul><h4>Leggi di De Morgan:</h4>
<p>non(P e Q) = non P o non Q <br />non(P o Q) = non P e non Q <br />In generale, una formula Q segue logicamente da una formula P se e solo se ogni interpretazione che soddisfa P soddisfa anche Q.
L'attività di concepire e scrivere programmi spesso richiede la dimostrazione di teoremi.
</p><h4>Insiemi</h4>
<ul><li>Il prodotto cartesiano di due insiemi A e B ha per cardinalità il prodotto delle cardinalità, quindi &#9553;A&#9553; · &#9553;B&#9553;
</li><li>L'insieme di tutte le funzioni f: A &#8594; B ha cardinalità &#9553;B&#9553;<sup>&#9553;A&#9553;</sup>
</li><li>L'insieme di tutti i sottoinsiemi di A ha cardinalità 2<sup>&#9553;A&#9553;</sup>
</li></ul><h4>Logica dei predicati</h4>
<p>Un termine può essere un simbolo individuale, una variabile o una funzione. (infatti se f è una funzione n-aria e t<sub>1</sub>,...,t<sub>n</sub> sono termini anche f(t<sub>1</sub>,...,t<sub>n</sub>) è un termine) <br />Nella logica dei predicati del prim'ordine i quantificatori si applicano solo alle variabili libere di una formula. <br />La logica dei predicati si distingue dalla logica proposizionale per la presenza di variabili, simboli individuali e funzioni.
</p><h4>Algoritmo</h4>
<p>Procedura passo per passo grazie alla quale un'operazione può essere svolta senza alcun esercizio di intelligenza e quindi, per esempio, da una macchina. <br />Deve comportare lo svolgimento in un numero finito di passaggi. Una ricetta di cucina è un esempio legittimo di algoritmo. <br />La complessità computazionale di un algoritmo è la quantità di risorse necessaria per la sua esecuzione. Per analizzare un algoritmo è necessario disporre di un modello della tecnologia che verrà utilizzata per realizzarlo.
In genere si usa la macchina RAM, nel cui modello le istruzioni vengono eseguite una dopo l'altra, senza operazioni concorrenti, ed ogni istruzione ha il suo tempo costante di esecuzione.
In generale, le risorse impiegate da un algoritmo aumentano al crescere della dimensione dei dati in ingresso. Il tempo di esecuzione di un algoritmo è dunque la somma dei tempi di esecuzione di tutti i passi eseguiti.
Per misurare lo spazio utilizzato da un algoritmo su un dato ingresso, occorre considerare la quantità massima di informazione che deve essere mantenuta istante per istante durante l'esecuzione, compresi i dati d'ingresso e di uscita.
La statistica che definisce la complessità di un algoritmo è il caso peggiore; il tempo di esecuzione nel caso peggiore è il più lungo tempo di esecuzione su tutti gli ingressi di dimensione n.
Perchè concentrarsi sul caso peggiore?
</p><ul><li>le risorse del caso peggiore costituiscono un limite superiore alle risorse che l'esecuzione dell'algoritmo richiederà mai.
</li><li>per alcuni algoritmi il caso peggiore si verifica abbastanza spesso.
</li><li>spesso il caso medio è tanto cattivo quanto il caso peggiore.
</li></ul><p>Quello che realmente determina la complessità di un algoritmo non è la quantità precisa di risorse che esso richiede nel caso peggiore, ma il suo tasso di crescita (ordine) al crescere delle dimensioni di ingresso.
Un algoritmo è più efficiente di un altro se le risorse richieste da esso nel caso peggiore hanno un ordine più basso.
Esempio:
</p><ul><li>n log n è più efficiente di n<sup>2</sup>
</li><li>n log n e 6n log n sono equivalenti
</li></ul><p>Problemi:
</p><ul><li>intrattabili: si conoscono solo algoritmi che li risolvono in un tempo esponenziale.
</li><li>indecidibili: non possono essere risolti in un tempo finito da alcun algoritmo e quindi da alcun programma. (es: il problema dell'arresto)
</li></ul><h4>Linguaggi di programmazione</h4>
<p>Una parola di un alfabeto è una sequenza finita di simboli dell'alfabeto.
Un linguaggio è un sottoinseme delle parole costruibili su un alfabeto.
Una grammatica è un insieme di regole di produzione per un linguaggio.
Un linguaggio è di alto livello se è vicino al modo di ragionare di chi lo utilizza; se invece è più vicino al modo di ragionare della macchina su cui i viene eseguito si dice di basso livello.
</p><h4>Programmazione</h4>
<p>Le cinque fasi della programmazione sono: specifica, progettazione, modellazione, codifica, verifica e correzione. <br />Specifica: <br />Una specifica è un quadrupla formata da insieme di ingressi, insiemi di uscite, precondizioni e postcondizioni <br />Progettazione: <br />I due approcci antitetici della progettazione sono l'analisi top-down e bottom-up.
</p><ul><li>top-down: parte dai requisiti che devono essere soddisfatti per risolvere il problema, i quali vengono poi divisi in un numero più piccolo di sottorequisiti e così via fino a che si ottengono solo compiti elementari.
</li><li>bottom-up: parte dai compiti elementari che si sanno già risolvere combinandoli per svolgere compiti più complessi, fino a risolvere l'intero problema.
</li></ul><p>Progettazione ad oggetti: analizza il problema per identificare tutti gli elementi rilevanti che compaiono nella definizione. <br />Verifica e correzione: <br />Collaudo empirico, ossia testare il programma con dati di prova e vedere se i risultati sono sempre corretti. La scelta dei dati di prova deve rispettare la massima copertura, ossia cercare di esercitre tutte le istruzioni del programma. <br /><br />Lo pseudocodice è uno strumento di modellazione della programmazione.
</p><h4>Documentazione</h4>
<ul><li>Documentazione interna: commenti, formattazione e asserzioni
</li><li>Documentazione esterna: documenti di progetto che sono separati dal programma. (documenti di specifica, spiegazioni scritte, manuali di riferimento, schemi e diagrammi.
</li><li>manuali: corredo del programma dopo la fase di collaudo
<ul><li>manauale utente: per chi dovrà usare il programma
</li><li>manuale di riferimento: per i programmatori che potrebbero usare il programma come compente di un sistema software più grande.
</li></ul></li></ul><p><a href='#top'><span style='font-size:83%'><strong>Torna su</strong></span></a>
<a name='c1' id='c1'></a>
</p><h3>Capitolo 2</h3>
<h4>Misura dell'informazione</h4>
<p>L'unità di misura dell'informazione è il bit, definito come la quantità di informazione necessaria per decidere tra due alternative equiprobabili. <br />Per distinguere tra <em>n</em> alternative è necessaria una quantità di informazione pari a log<sub>2</sub> <em>n</em> bit.
Quattro cifre binarie contengono 4 bit di informazione.
Per rappresentare un intero <em>n</em> sono necessarie log<sub>2</sub>(n+1) cifre binarie. <br />Overflow: il risultato di un operazione è un numero troppo grande per essere rappresentato. <br />L'IEEE 754 è il formato standard per la rappresentazione dei numeri a virgola mobile; i valori speciali si rappresentano così:
</p><ul><li>zero: esponente tutto di zeri e mantissa tutta di zeri
</li><li>infinito: esponente tutto di uni e mantissa tutta di zeri
</li><li>NaN: espponente tutto di uni e mantissa non tutta di zeri
</li></ul><p>Codice ASCII: codifica i caratteri della tastiera mediante 7 cifre binarie. <br />Codice Unicode: codifica i caratteri secondo tre forme UTF-8, UTF-16 e UTF-32.
</p><pre  style='text-align: center; background-color: red; border: 3px dotted yellow; padding: 3px;'>  <strong>Mixal</strong>
</pre><p>L'unità base per l'immagazzinamento dell'informazione nella macchina MIX è un byte di 6 bit. Una parola è definita come un insieme di 5 byte più un bit di segno.
Specifica di campo: forma (L:R), dove L è l'indice del primo byte ed R quello dell'ultimo. S=8L+R.<br />Il registro rAX è costituito da 10 byte più un bit di segno. <br />Per realizzare un sottoprogramma senza usare lo stack: la prima istruzione del sottoprogramma è STJ USCITA, dove USCITA è il punto di uscita, contenente l'istruzione JMP *. <br />Se uso lo stack devo dedicare uno dei registri indice a puntatore alla cima dello stack. <br />Le istruzioni vengono tradotte in linguaggio macchina, le direttive no. <br />L'asterisco rappresenta il valore corrente del contatore di locazione.
</p><h4>Direttive</h4>
<p>ORIG: specifica la locazione di memoria a partire dalla quale l'assemblatore deve cominciare ad inserire le istruzioni macchina in memoria. <br />EQU: definisce un simbolo e gli assegna un valore numerico. <br />CON: copia nella locazione di memoria corrente il risultato di un'espressione data. (serve a specificare il contenuto di una locazione di memoria) <br />ALF: prende un operando di 5 caratteri che costituiranno i byte di una parola da scrivere in memoria alla locazione corrente. <br />END: segnala la fine del programma e prende un operando che specifica la locazione di inizio per l'esecuzione del programma.
</p><pre  style='text-align: center; background-color: red; border: 3px dotted yellow; padding: 3px;'>  <strong>Fine Mixal</strong>
</pre><p>Mappa della memoria: assegnamento di un'area di memoria a ciascun dato. <br />Variabile: nome simbolico di una zona di memoria allocata per contenere un dato di un certo tipo. <br />Heap: zona di memoria utilizzata per allocare dinamicamente spazio per i dati di un programma.
Tabella: organizzazione ripetitiva di dati in memoria. <br />Se <em>x</em> è l'indirizzo della tabella e il dato base occupa <em>s</em> celle di memoria, l'indirizzo dell'i-esimo elemento sarà: x+ is. <br />Nel caso di una tabella bidimensionale m <em>x</em> n, l'indirizzo dell'elemento x<sub>ij</sub> sarà: x + s(im+j).<br />Il modo più intuitivo per realizzare una tabella a d dimensioni è pensarla come una tabella unidimensionale di tabelle a d-1 dimensioni. <br />Sottoprogramma: rende un programma più compatto ma ne rallenta l'esecuzione. <br />Lo stack è una struttura LIFO (last in, first out); le uniche operazioni che si possono compiere su di esso sono PUSH e POP. <br />Ricorsione: modo di specificare un'entità in termini di sè stessa ma non in modo circolare. Il concetto di ricorsione è strettamente collegato a quello di induzione in matematica. <br />Base della ricorsione: definizione di un caso elementare. <br />Passo della ricorsione: definizione di un'entità come combinazione di parti più semplici. <br />Divide et Impera: consiste nello scomporre un problema in sottoproblemi dello stesso tipo più semplici da risolvere. Porta alla scrittura di programmi ricorsivi. <br />Interprete: programma che esegue le istruzioni di un altro programma scritto in un altro linguaggio di programmazione. <br />Automi: la funzione di transizione di stato dato uno stato ed un simbolo letto dice in quale stato andrà l'automa.
<a href='#top'><span style='font-size:83%'><strong>Torna su</strong></span></a>
<a name='c2' id='c2'></a>
</p><h3>Capitolo 3</h3>
<h4>Programmazione strutturata</h4>
<p>La programmazione strutturata rappresenta la naturale estensione dell'approccio top-down. <br />Attività di processo: compito elementare. <br />Attività di gestione: decisione, selezione o iterazione. <br />Profondità: un modulo non dovrebbe contenere più di tre livelli di strutture di controllo una dentro l'altra. <br />Coesione funzionale: essere volto ad ottenere un solo scopo specifico o a realizzare una ben precisa funzionalità. <br />I costrutti di controllo fondamentali della programmazione strutturata sono 3: esecuzione seriale, iterazione e selezione. Altro principio guida della programmazione strutturata è che ciascun modulo o blocco di codice deve avere esattamente un punto di ingresso e un punto di uscita.
</p><h4>Linguaggi di alto livello</h4>
<p>I linguaggi di programmazione di alto livello sono (almeno idealmente) indipendenti dalla macchina, ossia quasi completamente portabile da una macchina all'altra. E' sufficiente ricompilarlo con il compilatore dell'altra macchina oppure farlo interpretare da un interprete del linguaggio della nuova macchina.
I linguaggi di alto livello sollevano il programmatore dalla gestione della memoria.
</p><h4>Altri paradigmi di programmazione</h4>
<ul><li>Imperativo: classico, basato su comandi
</li><li>Programmazione funzionale: valutazione di espressioni piuttosto che esecuzione di comandi
</li><li>Programmazione logica: descrivere la struttura logica piuttosto che come risolverla
</li></ul><h4>Tipo di dato</h4>
<p>Ogni entità che viene manipolata deve essere prima di tutto dichiarata
</p><h4>Gestione della memoria</h4>
<p>Tutti i linguaggi di alto livello gestiscono in modo automatico l'allocazione in memoria dei dati statici.<br />I linguaggi di alto livello differiscono per il supporto che offrono alla gestione delle strutture dati dinamiche.
</p><h4>Commenti</h4>
<p>In un programma C,C++ o Java i commenti sono delimitati dai simboli /* e */.
</p><h4>Variabili</h4>
<p>C,C++ e Java sono linguaggi fortemente tipati, ossia ogni variabile o espressione ha un tipo che può essere identificato leggendo il codice in cui compare; questo serve per aiutare il programmatore ad evitare certi errori comuni.
_swappa è un nome legittimo di variabile, anche se inizia con _ (underscore).
</p><h4>Vettori e Array</h4>
<p>In C,C++ e Java un vettore di 10 interi si dichiara così: int x[10]. Per le tabelle si usano i vettori di vettori definiti così: int tabella[5][7].
</p><h4>Funzioni</h4>
<p>Nella programmazione di alto livello i sottoprogrammi prendono il nome di procedure o funzioni.
</p><ul><li>Procedura: sottoprogramma che prende in ingresso zero o più argomenti o parametri, li elabora e non restituisce, almeno esplicitamente, nessun risultato al programma chiamante.
</li><li>Funzione: sottoprogramma che prende in ingresso zero o più argomenti e restituisce al programma chiamante un valore che è funzione degli argomenti.
</li></ul><h4>Costrutti di controllo</h4>
<p>Un blocco di istruzioni si crea scrivendo le istruzioni una di seguito all'altra e racchiudendole tra parentesi graffe.
</p><ul><li>while(&lt;condizione&gt;) &lt;istruzione&gt;: check della condizione, se soddisfatta eseguo l'istruzione e ricomincio.
</li><li>do &lt;istruzione&gt; while (&lt;condizione&gt;): eseguo l'istruzione almeno una volta, poi come un while normale.
</li><li>for (&lt;set&gt;;&lt;condizione&gt;;&lt;incremento&gt;) &lt;istruzione&gt;: semanticamente equivalente ad un while
</li><li>salto controllato:
<ul><li>break: interrompe l'esecuzione del ciclo e passa all'istruzione successiva
</li><li>continue: salta alla fine del ciclo e passa all'iterazione successiva
</li></ul></li></ul><h4>Costrutti di selezione</h4>
<ul><li>if (&lt;condizione&gt;) &lt;istruzione1&gt; else &lt;istruzione2&gt;: sceglie tra due alternative
</li><li>switch: sceglie tra n alternative
</li></ul><h4>Eliminazione dei salti</h4>
<p>Teorema di Bohm-Jacopini afferma che è possibile realizzare qualsiasi algoritmo senza utilizzare alcuna istruzione di salto disponendo dei tre costrutti di controllo.
L'idea è di trasformare un programma con salti in un unico ciclo while contentente tanti if. <br />Questo teorema è una giustificazione matematica della programmazione strutturata. <br />Una dimostrazione alternativa di questo teorema è dovuta ad Ashcroft e Manna; si rappresenta il programma con un diagramma di flusso, il quale può essere scomposto gerarchicamente in blocchi. Un blocco è un pezzo di diagramma con esattamente una freccia di entrata ed una freccia di uscita. <br /><strong>Esecuzione in sequenza e costrutto while</strong> sono sufficienti per realizzare qualsiasi algoritmo.
</p><h4>Strutture dati</h4>
<p>Una struttura dati è un modo sistematico di organizzare i dati utilizzati da un algoritmo e di accedere ad essi.<br /><br />&nbsp;
</p><table border='1' cellpadding='5' cellspacing='0' align='center' >
<tr ><th align='center'  valign='top'> Costrutto algoritmico
</th><th align='center'  valign='top'> Struttura dati
</th></tr><tr ><td align='center'  valign='top'> assegnamento
</td><td align='center'  valign='top'> tipo elementare
</td></tr><tr ><td align='center'  valign='top'> sequenza
</td><td align='center'  valign='top'> record
</td></tr><tr ><td align='center'  valign='top'> selezione
</td><td align='center'  valign='top'> record con variante
</td></tr><tr ><td align='center'  valign='top'> iterazione
</td><td align='center'  valign='top'> vettore
</td></tr><tr ><td align='center'  valign='top'> ricorsione
</td><td align='center'  valign='top'> struttura dati dinamica
</td></tr></table>
<p>&nbsp;
</p><h4>Correttezza dei programmi</h4>
<p>La verifica è formale, la validazione è empirica. Tra le due quella che da maggiori garanzie è la verifica. <br />La validazione può solo rivelare la presenza di errori, ma non è mai in grado di garantirne l'assenza!
</p><h4>Validazione</h4>
<p>Non si cercano casi di prova che si sa che il programma può superare, ma si tenta di costruire casi di prova capaci di trarre il programma in errore.
Buone norme per la validazione sono: esercitare tutto il codice, provare alcuni casi tipici, provare tutti i casi atipici e provare tutti i casi limite.
Test di regressione: nuova validazione di un codice in seguito a modifiche. (Solitamente si riutilizzano i casi di prova della prima validazione)
</p><ul><li>Correttezza totale: garanzia del soddisfacimento delle specifiche per qualsiasi ingresso in un numero finito di passi.
</li><li>Correttezza parziale: garanzia che, per ogni ingresso, il programma o non termina o, se termina, produce un risultato che soddisfa le specifiche.
</li></ul><p>Lo strumento principale per dimostrare la correttezza parziale di un programma scritto in un linguaggio imperativo è la logica di Hoare.
</p><pre  style='text-align: center; background-color: red; border: 3px dotted yellow; padding: 3px;'>  completare la parte sulla logica di hoare
</pre><h4>Asserzioni</h4>
<p>Un'asserzione è un costrutto condizionale che controlla una proprietà invariante e, nel caso in cui questa non sia verificata, produce intenzionalmente un errore di esecuzione.
</p><ul><li>C e C++ hanno una macro predefinita: void assert (int &lt;espressione&gt;);
</li><li>Java ha il costrutto: assert &lt;invariante&gt; [: &lt;espressione&gt; ];
</li></ul><h4>Modularità</h4>
<p>Sistema modulare, cioè suddiviso in unità funzionali separate, chiamate moduli, chiaramente individuate e caratterizzate da un livello di complessità gestibile.
Nella programmazione modularità significa identificare dei moduli semplici e ben delimitati in cui il programma può essere scomposto, in modo tale che ogni funzionalità sia confinata in un solo modulo e che le interazioni tra moduli siano il più possibile limitate e governate da convenzioni e regole certe.
</p>
<p class='vspace'><a href='#top'><span style='font-size:83%'><strong>Torna su</strong></span></a>
<a name='c3' id='c3'></a>
</p><h3>Capitolo 4</h3>
<h4>Programmazione orientata agli oggetti</h4>
<p>La programmazione orientata agli oggetti concentra l'attenzione sui dati da manipolare piuttosto che sulle procedure.
</p><h4>Astrazione</h4>
<p>Distillare un sistema complicato nei suoi costituenti più fondamentali e descrivere questi costituenti in modo semplice ma preciso.
</p><h4>Tipi di dati astratti</h4>
<p>Dato astratto corrisponde al concetto di interfaccia nella programmazione orientata agli oggetti. <br />Un tipo di dato astratto è un modello comprendente un tipo ed un insieme associato di operazioni, definite funzioni del tipo, di cui caratterizzano il comportamento.
Possiede un tipo, che è in pratica il nome che lo identifica, e definisce un insieme di operazioni, che costituiscono la sua interfaccia.
Il suo dominio di applicazione è definito da assiomi e precondizioni.
Un esempio di tipo di dato astratto è lo stack. Ecco un esempio di interfaccia per esso:
</p><ul><li>PUSH: precondizione stack non negativo?! (controllare!)
</li><li>TOP: precondizione è che lo stack contenga almeno un dato (strettamente positivo)
</li><li>DROP: precondizione è che lo stack contenga almeno un dato (strettamente positivo)
</li></ul><h4>Incapsulamento</h4>
<p>Processo mediante il quale vengono definiti degli oggetti software individuali. Stretta relazione tra il concetto di incapsulamento e quello di tipo di dato astratto. <br />L'idea è quella di nascondere i dettagli implementativi.
</p><h4>Classi ed Oggetti</h4>
<ul><li>Classe: automobili
</li><li>Oggetto: panda van 4x4 gialla targata AA123BB
</li></ul><p>Gli oggetti si caratterizzano per i loro attributi (nome, modello, colore, targa) e le classi per le operazioni che possono essere eseguite su di esse (accesa, spenta, ecc).
Le operazioni che si possono compiere su un oggetto o su una classe si chiamano <strong>metodi</strong>.
</p><h4>Riuso del software</h4>
<p>Tre metodi fondamentali:
</p><ul><li>Librerie di componenti riusabili
</li><li>Schemi trasformazionali a spettro ristretto
</li><li>Schemi trasformazionali ad ampio spettro
</li></ul><p class='vspace'>Compilazione ed utilizzo di librerie, cioè repertori di componenti riusabili. Si possono prendere dei componenti presenti in libreria ed usarli così come sono o prendere un componente che si avvicina alle funzionalità richieste e modificarlo per adattarlo allo scopo. <br />La programmazione orientata agli oggetti è quella che meglio si presta al riuso del software, in particolare quello basato sulle librerie di componenti.
</p><h4>Pattern</h4>
<p>Un pattern descrive un problema che si incontra più volte nello scrivere programmi e il nucleo della sua soluzione. In generale è costituito da:
</p><ol><li>Nome
</li><li>Descrizione del problema
</li><li>Soluzione
</li><li>Conseguenze
</li></ol><h4>Componenti</h4>
<p>Un componente è un programma capace di svolgere qualche compito, ma che è concepito in modo da poter funzionare in diversi ambienti ed essere agganciato ad altri componenti per creare delle applicazioni complete. I componenti possono essere scritti ciascuno in un linguaggio diverso, magari orientato agli oggetti, e quindi contenere oggetti.
</p><h4>Programmazione orientata agli aspetti</h4>
<p>Aspetti: punti di vista che caratterizzano un programma, ad esempio:
</p><ul><li>compito svolto dal programma (funzionalità)
</li><li>come gestisce le anomalie
</li><li>come viene garantita la sicurezza
</li><li>come comunica con altri componenti
</li></ul><p>La programmazione orientata agli aspetti consiste nel programmare ciascuno degli aspetti nella maniera più naturale, utilizzando cioè un apposito linguaggio di descrizione dell'aspetto distinto per ciascun aspetto. <br />Il vantaggio è che separare i vari aspetti di un sistema produce maggiore chiarezza e aumenta la facilità di intervenire su un solo aspetto senza influenzarne altri, promuovendo così la creazione di componenti riutilizzabili.
</p><h4>Classi, interfacce ed oggetti in Java</h4>
<p><strong>Static</strong>: il metodo appartiene alla classe ma non ai suoi oggetti.
<strong>This</strong>: i metodi della classe si riferiscono esplicitamente all'oggetto a cui appartengono.
</p><h4>Ereditarietà</h4>
<p>L'ereditarietà è la caratteristica di un linguaggio orientato agli oggetti per cui gli oggetti di una classe ereditano tutte le proprietà (attributi, metodi, ecc.) definite per gli oggetti delle classi di livello superiore.
<strong>Principio di sostituibilità di Liskov</strong>: B è un sottotipo di A se e solo se per ogni programma che usa oggetti di classe A posso usare al loro posto oggetti di classe B senza modificare il suo comportamento logico. <br />Due tipi di ereditarietà:
</p><ol><li>ereditarietà di interfaccia
</li><li>ereditarietà di realizzazione
</li></ol><p>1. Sostanzialmente riuso del software; si riutilizza il codice definito nelle classi genitrici. <br />2. Compatibilità fra tipi con lo scopo di consentire il <a href='#polimorfismo'>polimorfismo per inclusione</a>. <br />Quando una classe ha più di una classe genitrice si parla di ereditarietà multipla.
</p><h4>Polimorfismo</h4>
<p>Capacità di cose diverse di apparire nella stessa forma in un determinato contesto.
(Ad esempio: se scrivo una funzione per calcolare il massimo tra due numeri interi in C, non posso poi usarla per confrontare due numeri decimali; devo scrivere una funzione identica ma con variabili di tipo diverso. Questo perchè C è basato sul concetto che le funzioni, ed i loro argomenti, siano monorfiche.) <br />I quattro tipi di polimorfismo classificati da Cardelli e Wegner sono:
</p><ul><li>Overloading: stessa funzione applicabile a tipi diversi
</li><li>Coercion: argomenti di una funzione o di un operatore trasformati implicitamente nel tipo applicabile
</li><li>Parametrico: le funzioni sono parametrizzate secondo il tipo a cui possono essere applicati (alla base della programmazione generica)
</li><li><a name='polimorfismo' id='polimorfismo'></a> Per inclusione: un metodo può essere applicato a tutti gli oggetti inclusi nella classe che lo ammette (alla base della programmazione orientata agli oggetti)
</li></ul><h4>Errori ed eccezioni</h4>
<p>Un'eccezione è un'anomalia di funzionamento, una condizione imprevista dureante l'esecuzione di un programma. (Es: divisione per zero, aprire file non esistente, ecc.) <br />Java gestisce le anomalie di esecuzione con la classe predefinta <em>Throwable</em> e le sottoclassi <em>Error</em> ed <em>Exception</em>.<br />Un'eccezione può essere intercettata mediante il costrutto di controllo <strong>try</strong> ... <strong>catch</strong>.
</p><h4>Interfacce utente</h4>
<p>Qualsiasi cosa permetta ad un programma di interagire con l'utente.
</p><ul><li>Interfaccia utente a carattere (dialogo tramite il terminale)
<ul><li>guidata: menu o richieste di inserimento dati; l'utente sceglie tra un numero limitato di opzioni
</li><li>libera: il programma espone un prompt che segnala all'utente di essere in attesa di comandi (più complicata ma molto più potente)
</li></ul></li><li>Interfaccia grafica: si parla di programmazione guidata dagli eventi poichè la successione delle operazioni svolte dal programma non è predeterminata, ma dipende dalla particolare successioni degli eventi sia causati dall'utente che da altre applicazioni)
</li></ul><p><br /><a href='#top'><span style='font-size:83%'><strong>Torna su</strong></span></a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/TettyRiassunto)</span></div>
  </div>
</body>
</html>
