<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Ingegneria del Software - Appunti del 23 Marzo 2009</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='IDS-23Marzo.html' title='Ingegneria del Software - Appunti del 23 Marzo 2009'>Ingegneria del Software - Appunti del 23 Marzo 2009</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
<a class='wikilink' href='IngegneriaDelSoftware.html'>Torna alla pagina di Ingegneria del Software</a>
</p>
<div class='vspace'></div><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: Ingegneria del Software - Appunti del 23 Marzo 2009 ::</strong>
</pre><div class='vspace'></div><h2>Perché gli automi non ci piacciono</h2>
<p>Come abbiamo visto, gli automi sono belli etc. ma hanno dei limiti relativi ai fattori legati al tempo (sincronizzazione) e alla mancanza di memoria.
</p>
<p class='vspace'>Prendiamo questo semplice esempio: voglio un automa che riconosca e accetti le stringhe del tipo <strong>a<sup>m</sup>b<sup>m</sup></strong>, ovvero  in cui la <strong>a</strong> compaia lo stesso numero di volte della <strong>b</strong>.
</p>
<p class='vspace'>Finché <strong>m</strong> è un numero ragionevole e noto a priori, posso costruire il mio automa (immaginate il numero esorbitante di stati) che riconosca queste stringhe. Ma se <strong>m</strong> invece è un numero arbitrario, non c'è modo di costruire un automa che risolva questo problema. Notiamo per inciso che gli automi con un grande e ingestibile numero di stati sono detti <strong>automazzi</strong>.
</p>
<p class='vspace'>Esistono però gli <strong>automi con memoria</strong>, detti <strong>PDA</strong>, ovvero <strong>pushdown automata</strong>. La memoria, in questo tipo di automi, viene modellata tramite uno stack (push è l'operazione di mettere un elemento in cima allo stack). Le transizioni dipenderanno quindi dallo stato presente, dall'input e dall'elemento in cima allo stack, e porteranno ad un nuovo stato e ad una diversa cima dello stack. Tornando al nostro esempio, lo implementeremo facendo in modo che una stringa <em>a</em> aggiunga un elemento allo stack, e che <em>b</em> lo tolga. In questo modo potremo rappresentare semplicemente i requisiti di temporizzazione dicendo che se lo stack è vuoto allora abbiamo lo stesso numero di occorrenze delle due stringhe.
</p>
<p class='vspace'  style='text-align: center; background-color: red; border: 3px dotted yellow; padding: 3px;'><span  style='color: white;'><strong>I PDA non sono da studiare!</strong></span>
</p>
<p class='vspace'>Il motivo per cui non guardiamo i PDA è che vogliamo altri modelli che non siano solo più espressivi, ma anche più compatti, ovvero le <strong>reti di Petri</strong>.
</p>
<div class='vspace'></div><h2>Le reti di Petri</h2>
<p>Le reti di Petri sono un <strong>grafo bipartito</strong>. Un grafo bipartito è un grafo in cui i nodi possono essere di due tipi, e ha la regola stringente per cui un nodo di un tipo non può mai essere connesso tramite un arco ad un altro nodo dello stesso tipo. Pertanto, gli archi connettono sempre nodi di tipo diverso.
</p>
<p class='vspace'>I tipi di nodo sono i seguenti:
</p><ul><li><strong>posti</strong>, rappresentati con un <strong>cerchio</strong>
</li><li><strong>transizioni</strong>, rappresentate con un <strong>quadrato</strong>
</li></ul><p class='vspace'>Oltre ai posti ed alle transizioni, una rete di Petri contiene anche un certo numero di <strong>token</strong>. I token vengono rappresentati con dei pallini neri, che vengono disegnati nei posti. Un posto può contenere anche più di un token in un dato istante, o anche non contenerne nessuno.
</p>
<p class='vspace'>Uno <strong>stato</strong> è una certa distribuzione di token nei posti. Attenzione: non confondiamo gli stati degli automi, rappresentati anch'essi con dei cerchi, con i posti delle reti di Petri, confusionariamente rappresentati anch'essi con dei cerchi.<br />
</p><div><span class='frame lfloat'><img src='../uploads/Uni/IDSpetri2stati.png' alt='' title='' /><br />2 stati differenti</span></div>
<p class='vspace'>In quest'immagine vediamo la stessa rete di Petri, disegnata a sinistra e a destra. Quello che cambia è la distribuzione dei token nei posti, e questo vuol dire che la rete di sinistra rappresenta uno stato diverso rispetto alla rete di destra.
</p>
<p class='vspace'>Le <strong>precondizioni</strong> di una transizione sono l'insieme di tutti quei posti che sono collegati alla transizione con delle frecce entranti (ovvero delle frecce che escono dai posti ed entrano nella transizione).
</p>
<p class='vspace'>Le <strong>postcondizioni</strong> di una transizione sono invece l'insieme di tutti i posti collegati alla transizione da frecce uscenti.
</p>
<div class='vspace'></div><h3>Regola di scatto</h3>
<p>Si ha uno <strong>scatto</strong> quando una transizione viene attivata (abilitata). La <strong>regola di scatto</strong> dice che una transizione scatta quando <strong>tutte le sue precondizioni sono soddisfatte</strong>, il che vuol dire, secondo le definizioni viste qui sopra, che scatta quando tutti i posti ad essa collegati con frecce entranti sono pieni.
</p>
<p class='vspace'><strong>Dopo lo scatto</strong>, la transizione ridistribuisce i token nelle proprie <strong>postcondizioni</strong>.
</p>
<p class='vspace'>Nell'immagine qui sopra, possiamo immaginare che sia avvenuto uno scatto che abbia portato un token dal posto superiore al posto inferiore. Il risultato di uno scatto è una <strong>redistribuzione</strong> dei token, il che vuol dire, secondo la definizione di stato vista sopra, che una transizione quando scatta fa <strong>cambiare stato</strong> alla mia rete di Petri. Questa è la <strong>semantica</strong> della mia rete di Petri: una funzione che associa il tempo alla diversa successione di stati, o in altre parole, alla sua evoluzione. Se ogni stato è a sua volta una funzione che associa ad ogni posto un certo numero di token, allora la vita della rete di Petri è una successione di funzioni di questo tipo.
</p>
<div class='vspace'></div><h3>Comportamento del software</h3>
<p>Partiamo da una domanda: dato un certo assegnamento di token in una rete di Petri, sarà possibile in futuro avere un'altra situazione data? Ovvero, potrò fare delle previsioni?
</p>
<p class='vspace'>Si tratta di una domanda matematica che, per via del fatto che le reti di Petri hanno una semantica, è calcolabile e dimostrabile: in questo modo è possibile stabilire l'esatto comportamento di una rete di Petri.
</p>
<p class='vspace'>Ma a noi ingegneri del software non interessa solo questo: vogliamo che il nostro programma rispetti fino in fondo il comportamento della rete di Petri che tanto ci siamo sbattuti a costruire, in particolar modo per ciò che concerne le regole di scatto.
</p>
<p class='vspace'>Se riusciamo a garantire che il nostro software si comporti esattamente come la rete di Petri, allora siamo a posto. Ma come faccio? La soluzione consiste nell'avere un generatore di codice automatico che, data una rete di Petri, produce automaticamente del codice sorgente il cui comportamento rispetta quello della rete. Questo algoritmo esiste ed è validato, e si dimostra molto molto utile per quei programmi in cui la maggior parte dei requisiti sono di temporizzazione e sincronizzazione (in aula ha fatto l'esempio delle funivie).<br />Ricordiamo fino alla nausea che l'algoritmizzazione di un tale procedimento è possibile proprio perché le reti di Petri sono dotate sia di sintassi che di semantica.
</p>
<div class='vspace'></div><h3>Purezza della rete</h3>
<p>Una rete di Petri è detta <strong>pura</strong> se gli insiemi delle precondizioni e delle postcondizioni sono <strong>disgiunti</strong>. Vuol dire che non esistono anelli che congiungono una transizione con se stessa, o meglio che non deve esistere nessun posto collegato alla stessa transizione sia in entrata che in uscita. Possiamo verificare tale proprietà anche nelle matrici I e O che vedremo successivamente.
</p>
<p class='vspace'>Il requisito di purezza di una rete di Petri è fondamentale per poter dimostrare alcuni teoremi matematici su di essa, in particolar modo quelli che ne riguardano il funzionamento e l'evoluzione. Man mano che allargo la classe dei problemi diventa sempre più difficile da garantire.
</p>
<div class='vspace'></div><h3>Parentesi: automi e teoremi</h3>
<p>Anche con gli automi potrei dimostrare dei teoremi, ad esempio che non è possibile arrivare ad un certo stato dopo determinati passaggi, ma si tratta di una dimostrazione che va avanti per enumerazione elencando tutti i passaggi, quindi nel migliore dei casi ci metto un'eternità (sperando sempre che non ci siano cicli). <br />Esistono tuttavia tecniche più compatte che però non sono sempre applicabili, ma solo per certi tipi di dimostrazioni e solo in certi casi. Una di queste è il <em>lemma di espansione</em>, che si applica felicemente a casi come questi:
</p>
<div class='vspace'></div><table cellpadding='10' cellspacing='10' width='80%' >
<tr ><td width='46%' align='center' valign='middle' bgcolor='#f9f9f9' >
<div><img src='../uploads/Uni/IDSlemmaEsp1.jpg' alt='' title='' /> <br /><strong>Riesco a dimostrare con l'enumerazione che non posso arrivare allo stato OK senza avere almeno un <code class='escaped'>a</code></strong></div>
</td><td align='center'  valign='top'><span style='font-size:120%'><code class='escaped'>-&gt;</code></span><br /><strong>aggiungo</strong><br /><strong>un ciclo</strong><br /><span style='font-size:120%'><code class='escaped'>-&gt;</code></span>
</td><td width='46%' align='center' valign='middle' bgcolor='#f9f9f9' >
<div><img src='../uploads/Uni/IDSlemmaEsp2.jpg' alt='' title='' /> <br /><strong>Quanto detto prima resta vero anche con l'aggiunta del ciclo, dimostrazione che non potrei fare per dimostrazione.</strong></div>
</td></tr></table>
<div class='vspace'></div><h2>Definizione formale delle reti di Petri</h2>
<p>Una rete di Petri è una quadrupla (P, T, I, O):
</p><ul><li><strong>P</strong> = insieme dei posti
</li><li><strong>T</strong> = insieme delle transizioni
</li><li><strong>I</strong> e <strong>O</strong> sono due matrici <strong>|P| x |T|</strong>, traduzioni di <strong>T</strong> in un <strong>multinsieme</strong> di posti
</li></ul><p class='vspace'>La faccenda del multinsieme è un po' particolare... Innanzitutto, un multinsieme è un insieme in cui un elemento può comparire più volte. Il generico elemento <strong>I(i,j)</strong> rappresenta l<strong>'input</strong> della transizione <strong>j</strong>. Il generico elemento <strong>O(i,j)</strong> rappresenta invece l<strong>'output</strong> della transizione <strong>j</strong>.
</p>
<p class='vspace'>Nella posizione <strong>I(i,j)</strong> metto un <strong>1</strong> se il posto <strong>i-esimo</strong> è precondizione della transizione <strong>j-esima</strong>, <strong>0</strong> altrimenti.
</p>
<p class='vspace'>Allo stesso modo, nella posizione <strong>O(i,j)</strong> metto un <strong>1</strong> se il posto <strong>i-esimo</strong> è postcondizione della transizione <strong>j-esima</strong>, e <strong>0</strong> in caso contrario.
</p>
<div class='vspace'></div><div><span class='frame lfloat'><img src='../uploads/Uni/IDS3p3t.png' alt='' title='' /></span></div>
<p>Nella rete qui accanto (<strong>disegno mancante!</strong>) ho tre posti e tre transizioni. Vediamo di compilare le nostre matrici I e O.
</p>
<div class='vspace'></div><table width='45%' border='0' cellpadding='5' cellspacing='0' align='center' >
<tr ><td colspan='4' align='center'  valign='top'><strong>Matrice I:</strong>
</td></tr><tr ><td  valign='top'> 
</td><td bgcolor='#d9e4f2'  valign='top'> <strong>T1</strong>
</td><td bgcolor='#d9e4f2'  valign='top'> <strong>T2</strong>
</td><td bgcolor='#d9e4f2'  valign='top'> <strong>T3</strong>
</td></tr><tr ><td bgcolor='#d9e4f2'  valign='top'> <strong>P1</strong>
</td><td  valign='top'> 1
</td><td  valign='top'> 0
</td><td  valign='top'> 0
</td></tr><tr ><td bgcolor='#d9e4f2'  valign='top'> <strong>P2</strong>
</td><td  valign='top'> 1
</td><td  valign='top'> 0
</td><td  valign='top'> 0
</td></tr><tr ><td bgcolor='#d9e4f2'  valign='top'> <strong>P3</strong>
</td><td  valign='top'> 0
</td><td  valign='top'> 1
</td><td  valign='top'> 1
</td></tr></table> <br />
<div class='vspace'></div><table width='45%' border='0' cellpadding='5' cellspacing='0' align='center' >
<tr ><td colspan='4' align='center'  valign='top'><strong>Matrice O:</strong>
</td></tr><tr ><td  valign='top'> 
</td><td bgcolor='#d9e4f2'  valign='top'> <strong>T1</strong>
</td><td bgcolor='#d9e4f2'  valign='top'> <strong>T2</strong>
</td><td bgcolor='#d9e4f2'  valign='top'> <strong>T3</strong>
</td></tr><tr ><td bgcolor='#d9e4f2'  valign='top'> <strong>P1</strong>
</td><td  valign='top'> 0
</td><td  valign='top'> 1
</td><td  valign='top'> 0
</td></tr><tr ><td bgcolor='#d9e4f2'  valign='top'> <strong>P2</strong>
</td><td  valign='top'> 0
</td><td  valign='top'> 0
</td><td  valign='top'> 1
</td></tr><tr ><td bgcolor='#d9e4f2'  valign='top'> <strong>P3</strong>
</td><td  valign='top'> 1
</td><td  valign='top'> 0
</td><td  valign='top'> 0
</td></tr></table> <br />
<p>Una matrice vale più di mille parole:)
</p>
<p class='vspace'>La <strong>marcatura</strong> è invece un vettore colonna, con tanti elementi quanti sono i posti, e ha quindi la stessa dimensione della colonna di una matrice. Una marcatura è un <strong>assegnamento</strong> di token ai posti della nostra rete, ed è pertanto la rappresentazione di uno stato. Una rete di Petri si "sposterà" da una marcatura ad un'altra.
</p>
<p class='vspace'>Il fatto di rappresentare le precondizioni e le postcondizioni tramite matrici ci permette di rappresentare le <strong>variazioni di marcatura</strong> tramite un'altra matrice, chiamata <strong>matrice di incidenza</strong> (<strong>C</strong>).<br />La <strong>C</strong> è definita come <strong>O - I</strong>, il che vuol dire che ogni elemento della matrice <strong>C</strong> contiene la sottrazione del corrispondente elemento di <strong>I</strong> dal corrispondente elemento di <strong>O</strong>.
</p>
<p class='vspace'>Per la rete che abbiamo visto sopra, la corrispondente matrice <strong>C</strong> sarà come segue:
</p>
<div class='vspace'></div><table width='45%' border='0' cellpadding='5' cellspacing='0' align='center' >
<tr ><td colspan='4' align='center'  valign='top'><strong>Matrice O:</strong>
</td></tr><tr ><td  valign='top'> 
</td><td bgcolor='#d9e4f2'  valign='top'> <strong>T1</strong>
</td><td bgcolor='#d9e4f2'  valign='top'> <strong>T2</strong>
</td><td bgcolor='#d9e4f2'  valign='top'> <strong>T3</strong>
</td></tr><tr ><td bgcolor='#d9e4f2'  valign='top'> <strong>P1</strong>
</td><td  valign='top'> -1
</td><td  valign='top'> 1
</td><td  valign='top'> 0
</td></tr><tr ><td bgcolor='#d9e4f2'  valign='top'> <strong>P2</strong>
</td><td  valign='top'> -1
</td><td  valign='top'> 0
</td><td  valign='top'> 1
</td></tr><tr ><td bgcolor='#d9e4f2'  valign='top'> <strong>P3</strong>
</td><td  valign='top'> 1
</td><td  valign='top'> -1
</td><td  valign='top'> -1
</td></tr></table> <br />
<p>Pertanto il singolo elemento <strong>C(i,j)</strong> rappresenta la <strong>variazione di marcatura</strong> del posto <strong>i-esimo</strong> dovuta alla transizione <strong>j-esima</strong>. La matrice di incidenza mi dice quindi come cambia il numero di marcatori in un posto allo scattare delle condizioni di attivazione.
</p>
<p class='vspace'>E notiamo bene che è possibile utilizzare la matrice <strong>C</strong> al posto di <strong>I</strong> e di <strong>O</strong>, perché le "riassume" entrambe, ma solo a condizione che la nostra rete di Petri sia <strong>pura</strong>: il  motivo è che se una rete non è pura, allora avrei dei posti che sono sia precondizione che postcondizione di qualche transizione, e pertanto non saprei come rappresentare la variazione di marcatura (considererei due volte lo stesso token). Oh, è più facile da capire che da spiegare:)
</p>
<p class='vspace'>Per sapere la marcatura di una rete dopo una certa transizione <strong>i</strong>, possiamo applicare la seguente formula matematica:
</p><pre> M' = M + C(*, i)
</pre><p>che significa: la marcatura <strong>M</strong>' è equivalente alla marcatura iniziale <strong>M</strong>, alla quale applico l'intera colonna <strong>i-esima</strong> della matrice <strong>C</strong>, che è appunto la matrice delle variazioni di marcatura relative alla transizione <strong>i</strong>.<br />Questa è l'equazione fondamentale della rete, e mi fornisce una traiettoria dell'evoluzione della rete di Petri stessa.
</p>
<p class='vspace'>Allo stesso modo, una <strong>combinazione di transizioni</strong> la posso formulare così:
</p><pre> M' = M + C(*, i) + C(*, j) + ... + C(*, n)
</pre><p>e la posso riassumere con
</p><pre> M' = M + Cs
</pre><p>dove <strong>s</strong> è una stringa che seleziona le colonne della matrice <strong>C</strong> da applicare in sequenza a <strong>M</strong>.
</p>
<p class='vspace'>Dal punto di vista grafico, una freccia che conduce da un posto ad una transizione è etichettata da un numero che indica quanti token vengono spostati da quella transizione. L'assenza di indicazioni sottointende un canale di capacità 1.
</p>
<div class='vspace'></div><h3>Estensioni alle reti di Petri</h3>
<p>Supponiamo di voler modellare con una rete di Petri un sistema rappresentato da una CPU che deve accedere a tre dischi diversi. Ai dischi si accede con due canali: il primo canale porta al primo e al secondo disco, mentre il secondo canale porta al secondo e al terzo disco (il secondo disco è quindi raggiungibile tramite due canali diversi). Si può petrificare una rete del genere?
</p>
<p class='vspace'>La CPU, in teoria, a seconda della destinazione, sa a quale controller inviare i dati, e dal punto di vista del programmatore non è affatto un problema. Ma al livello della rete di Petri, avendo solamente token a disposizione, come facciamo a <em>distinguere</em> tra un token che rappresenta una scrittura verso un disco da un altro token che invece vuole scrivere su un altro disco?
</p>
<p class='vspace'>I token rappresentano spesso oggetti o risorse, ma nel mondo reale (e in quello informatico) gli oggetti e le risorse hanno delle proprietà. Invece i token, per come li abbiamo definiti noi, non hannno affatto queste proprietà!
</p>
<p class='vspace'>La soluzione a problemi di questo genere verrà in futuro, quando tra le estensioni alle reti di Petri che ne aumentano il potere espressivo tireremo fuori dal cilindro quella dei <strong>colori</strong>.
</p>
<div class='vspace'></div><hr />
<p><a class='wikilink' href='IngegneriaDelSoftware.html'>Torna alla pagina di Ingegneria del Software</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/IDS-23Marzo)</span></div>
  </div>
</body>
</html>
