<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Algoritmi e strutture dati - Risposte Esami 2009</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='ALG-Risposte2009.html' title='Algoritmi e strutture dati - Risposte Esami 2009'>Algoritmi e strutture dati - Risposte Esami 2009</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
<a class='wikilink' href='Algoritmi.html'>Torna alla pagina di Algoritmi e strutture dati</a>
</p><hr />
<div class='vspace'></div><div class='round lrindent evvai' > 
<p>Questa pagina è stata aggiornata GRAZIE agli appunti che AVETE INVIATO nel periodo di chiusura della sezione UniCrema!! <strong><em>È SERVITA A QUALCOSA, NO?!</em></strong> <span style='font-size:144%'>;)</span>
</p></div>
<div class='vspace'></div><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: Algoritmi e strutture dati - Risposte Esami 2009 ::</strong>
</pre><div class='vspace'></div><h2>2 Novembre 2009</h2>
<p><a class='urllink' href='http://ananke.crema.unimi.it/~decapita/Algoritmi/Esami/2009-11-02.pdf' title='' rel='nofollow'>Testo dell'esame dal sito del docente</a> (.PDF)
</p>
<div class='vspace'></div><h4>Risposta 3.1</h4>
<p>I codici di Huffman vengono utilizzati per comprimere i file. Consentono di risparmiare uno spazio che va dal 20% al 90% in base al tipo di file. Si basano sulla frequenza delle lettere nel file che permettono la costruzione di un codice ottimo. Ogni carattere ha associata una parola codice che può essere di lunghezza fissa o variabile.<br />Utizza dei codici prefissi che è un codice in cui nessuna parola è prefisso di un altra.<br />La decodifica avviene in quattro fasi:
</p><ul><li>Fase 1: Viene trovata la prima parola nel file codificato.
</li><li>Fase 2: Viene tradotta la parola e scritta nel file di decodifica.
</li><li>Fase 3: Viene eliminata la parola dal file di codificato.
</li><li>Fase 4: Si ripete fino a che non è stato decodificato l'intero file.
</li></ul><p class='vspace'>Dato un file F, un codice C è ottimo per F se non esiste nessun altro codice che permette di risparmiare più spazio. Possono esistere più codici ottimi e sono rappresentato con un albero binario in cui ogni nodo interno ha due figli.<br />Il principio del codice di Huffman è il seguente: Deve minimizzare la lunghezza del codice delle parole più frequenti e assegnare ai caratteri con meno frequenza i codici corrispondenti ai percosi più lunghi all'interno dell'albero.<br />Ogni codice è progettato per uno specifico file e le fasi sono le seguenti:
</p><ul><li>Fase 1: Si ottengono le frequenze dei caratteri.
</li><li>Fase 2: Si costruisce il codice ottimo.
</li><li>Fase 3: Si rappresenta il file tramire il codice ottimo.
</li><li>Fase 4: Si aggiunge al file una rappresentazione del codice ottimo.
</li></ul><p class='vspace'>L'algoritmo di Huffman è gready perchè ad ogni passo costruisce il nodo interno avente la frequenza minima possibile.
</p>
<div class='vspace'></div><h4>Risposta 3.3</h4>
<p>Una componente fortemente connessa in un grafo orientato è un insieme massimale di
vertici U contenuti in V. Per ogni vertice u,v appartentente a U esiste un cammino che va da u a v e uno che va da v a u.<br />Si calcola in tre fasi:
</p><ul><li>Fase 1: Si usa la visita in profondità in G per ordinare i vertici in ordine di tempo di completamento f decrescente.
</li><li>Fase 2: Si calcola il grafo trasposto G' di G.
</li><li>Fase 3: Si esegue la visita in profondità su G' usando l'ordine dei vertici calcolato nella prima fase.
</li></ul><p class='vspace'>Gli alberi della vista in profondità del grafo trasposto rappresentano le componenti
fortemente connesse di G.
</p>
<div class='vspace'></div><h2>21 Settembre 2009</h2>
<p><a class='urllink' href='http://ananke.crema.unimi.it/~decapita/Algoritmi/Esami/2009-09-21.pdf' title='' rel='nofollow'>Testo dell'esame dal sito del docente</a> (.PDF)
</p>
<div class='vspace'></div><h4>Risposta 3.3</h4>
<p>L'ordinamento topologico di un grafo orientato è un ordinamento lineare dei suoi vertci tale che:
</p><ol><li>Per ogni arco uv appartenenti a E il vertice u precede il vertice v.
</li><li>Per transtitività, se u è raggiungibile da v allora u viene prima di v nell'ordinamento.
</li></ol><p class='vspace'>L'ordinamento topologico è utilizzato per determinare l'ordine di esecuzione di un insieme di attività in presenza di vincoli di precedenza.<br />Si può utilizzare la visita in profondità e per ordinare i vertici in ordine di tempo decrescente f di completamento oppure la soluzione diretta.<br />La soluzione diretta consiste nelle seguenti fasi:
</p><ol><li>Si cercano tutti i vertici che non hanno archi incidenti in ingresso.
</li><li>Si stampa il verticie e si elimina il vertice con i suoi archi.
</li><li>Si ripete la procedura fino a che non ci sono più vertici.
</li></ol><div class='vspace'></div><h2>20 Luglio 2009</h2>
<p><a class='urllink' href='http://ananke.crema.unimi.it/~decapita/Algoritmi/Esami/2009-07-20.pdf' title='' rel='nofollow'>Testo dell'esame dal sito del docente</a> (.PDF)
</p>
<div class='vspace'></div><h4>Risposta 3.3</h4>
<p>La visita in ampiezza BFS permette di visitare il grafo a partire da un vertice s detto sorgente e visita sistematicamente tutto il grafo per scoprire tutti i vertici raggiungibili da s. Calcola le distanze minime di ogni vertice da s. Produce anche un albero i cui rami sono cammini di lunghezza minima. La visita espande uniformemente la frontiera tra i vertici scoperti e quelli non ancora scoperti.<br />L'algoritmo funziona nel seguente modo: assume che il grafo sia rappresentato con liste di adiacenze. Tutti i nodi adiacenti ad un nodo, sono aggiunti ad una coda Q di tipo FIFO che memorizza la frontiera.<br />Descrizione:
</p><ol><li>All'inizio dell'algoritmo tutti i vertici sono bianchi tranne la sorgente da cui parte
</li></ol><p>l'esecuzione dell'algoritmo.
</p><ol><li>Con l'andare avanti nella visita i vertici del grafo vengono colorati di grigio, ed
</li></ol><p>inseriti nella coda, che in ogni istante conterrà tutti i nodi colorati di grigio, ma dei quali ancora non sono stati visitati gli adiacenti.
</p><ol><li>Quando tutti i nodi adiacenti ad un nodo grigio sono stati visitati e quindi colorati di grigio, il nodo verrà colorato di nero e rimosso da Q.
</li></ol><p>Il tempo di esecuzione di questo algoritmo è O(V+E).
</p>
<div class='vspace'></div><h4>Risposta 3.4</h4>
<p>Tecnica divide et impera: E' una tecnica ricorsiva dove il problema viene diviso in sotto problemi indipendenti che vengono risolti ricorsivamente (strategia top-down). E' utile solo quando i sottoproblemi sono indipendenti altrimenti gli stessi sottoproblemi possono venire risolti più volte. Un algoritmo che ne fà utilizzo è il merge-sort.
</p>
<div class='vspace'></div><h2>17 Giugno 2009</h2>
<p><a class='urllink' href='http://ananke.crema.unimi.it/~decapita/Algoritmi/Esami/2009-06-17.pdf' title='' rel='nofollow'>Testo dell'esame dal sito del docente</a> (.PDF)
</p>
<div class='vspace'></div><h4>Risposta 2</h4>
<p>Ci sono due tecniche per visitare i grafi la DFS (visita in profondità) e la BFS (visita in ampiezza).<br />La visita in ampiezza BFS permette di visitare il grafo a partire da un vertice s detto sorgente e visita sistematicamente tutto il grafo per scoprire tutti i vertici raggiungibili da s. Calcola le distanze minime di ogni vertice da s. Produce anche un albero i cui rami sono cammini di lunghezza minima. La visita espande uniformemente la frontiera tra i vertici scoperti e quelli non ancora scoperti. L'algoritmo funziona nel seguente modo: assume che il grafo sia rappresentato con liste di adiacenze. Tutti i nodi adiacenti ad un nodo, sono aggiunti ad una coda Q di tipo FIFO che memorizza la frontiera.<br />Descrizione:
</p><ol><li>All'inizio dell'algoritmo tutti i vertici sono bianchi tranne la sorgente da cui parte l'esecuzione dell'algoritmo.
</li><li>Con l'andare avanti nella visita i vertici del grafo vengono colorati di grigio, ed
</li></ol><p>inseriti nella coda, che in ogni istante conterrà tutti i nodi colorati di grigio, ma dei quali ancora non sono stati visitati gli adiacenti.
</p><ol><li>Quando tutti i nodi adiacenti ad un nodo grigio sono stati visitati e quindi colorati di grigio, il nodo verrà colorato di nero e rimosso da Q.
</li></ol><p class='vspace'>Il tempo di esecuzione di questo algoritmo è O(V+E).
</p>
<p class='vspace'>La visita in profondità DFS esplora il grafo partendo da un vertice s detto sorgente. Si esplorano gli archi uscenti dal vertice u raggiunto per ultimo. Se viene scoperto un nuovo vertice ci si sposta su tale vertice. Se tutti gli archi uscenti da u portano a vertici già scoperti si torna indietro e si riprende esplorando archi uscenti dal vertice cui u è stato scoperto. Il procedimento continua fino a che sono stati scoperti tutti i vertici raggiungibili dal vertice s iniziale scelto. Se non sono stati tutti scoperti si ripete il procedimento partendo da un vertice non ancora raggiunto (si sceglie una nuova sorgente).<br />Si utilizzano due marcatempi:
</p><ol><li>d[u] che registra quando è stato scoperto un vertice e colorato di grigio.
</li><li>f[u] che registra quando il vertice è stato completamente visitato e viene colorato di nero.
</li></ol><p class='vspace'>Pseudocodice DFS:
</p>
<p class='vspace'><em>DFS(G)</em>
</p><div class='indent'><em>for ogni vertice u in V[G]</em>
<div class='indent'><em>do color[u] &#8592; WHITE</em>
<div class='indent'><em>&#960;[u] &#8592; NIL</em>
</div></div></div><div class='indent'><em>time &#8592; 0</em>
</div><div class='indent'><em>for ogni vertice u in V[G]</em>
<div class='indent'><em>do if color[u] = WHITE</em>
<div class='indent'><em>then DFS-Visit(u)</em>
</div></div></div><p class='vspace'><em>DFS-Visit(u)</em>
</p><div class='indent'><em>color[u] &#8592; GREY</em>
<div class='indent'><em>for ogni v in Adj[u]</em>
<div class='indent'><em>do if color[v] = WHITE</em>
<div class='indent'><em>then &#960;[v] &#8592; u</em>
<div class='indent'><em>DFS-Visit(v)</em>
</div></div></div></div></div><div class='indent'><em>color[u] BLACK</em>
</div><div class='indent'><em>f[u] &#8592; time &#8592; time + 1</em>
</div><p class='vspace'>Il tempo di esecuzione di questo algoritmo è O(|V|+|E|)
</p>
<div class='vspace'></div><hr />
<p><a class='wikilink' href='Algoritmi.html'>Torna alla pagina di Algoritmi e strutture dati</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/ALG-Risposte2009)</span></div>
  </div>
</body>
</html>
