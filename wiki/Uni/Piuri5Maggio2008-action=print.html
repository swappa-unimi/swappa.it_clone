<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Sistemi Operativi - Lezione del 5 maggio 2008</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='Piuri5Maggio2008.html' title='Sistemi Operativi - Lezione del 5 maggio 2008'>Sistemi Operativi - Lezione del 5 maggio 2008</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
</p><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: Sistemi Operativi - Lezione del 5 maggio 2008 ::</strong>
</pre><p class='vspace'><a class='wikilink' href='SistemiOperativi.html'>Torna alla pagina di Sistemi Operativi</a>
</p>
<p class='vspace'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 4 - Realizzazione dei Files - Allocazione dei blocchi</strong></span>
</p>
<p class='vspace'>Abbiamo visto che prediligiamo la tecnica del bytestream per realizzare i files. Ma i files sono composti da blocchi: con che criterio andiamo a scrivere questi blocchi sul disco? Ci sono diversi modi per allocare.
</p>
<div class='vspace'></div><h3>Allocazione contigua</h3>
<p>Semplicemente, metto i blocchi relativi ad un file uno dietro l'altro. La directory contiene la lista dei files, con
</p><ul><li>numero del blocco dove il tal file comincia
</li><li>lunghezza del file in blocchi
</li></ul><p class='vspace'>Sicuramente questo schema di allocazione ha il vantaggio che la lettura di un file intero è molto veloce, trattandosi di blocchi contigui: la testina non deve mai spostarsi dalla traccia in cui si trova.
</p>
<p class='vspace'>Il problema è l'accesso diretto (ricerca di un determinato punto del file), che è un po' più lento perché devo partire dall'inizio del file.
</p>
<p class='vspace'>Inoltre, i problemi più evidenti riguardano la frammentazione interna ed esterna, e la creazione dei files. Se per creare un file occorre spazio contiguo, è anche possibile <strong>non</strong> riuscire a trovarne: ci sono complessivamente tanti blocchi, ma tutti separati, e non posso usarli perché non contigui. È qui che deve entrare in campo quel simpatico processo chiamato <strong>deframmentazione</strong>, che cerca appunto di risolvere la frammentazione esterna.
</p>
<p class='vspace'>La frammentazione interna invece riguarda il fatto che devo assegnare spazio vuoto ad un file (ma quanto?) perché forse nel futuro lo userà.
</p>
<p class='vspace'>Per conoscere lo spazio libero nel sistema, leggo tutte le directory, faccio la somma dei blocchi liberi e ritorno il risultato. Ma siccome sto sistema sarebbe infinitamente lento, si usa anche una tabella esterna che tiene traccia del numero di blocchi liberi.
</p>
<div class='vspace'></div><h3>Allocazione collegata</h3>
<p>Tolgo dalle mie pretese l'obbligo di avere blocchi fisicamente contigui. Tratto i singoli blocchi come elementi di una <strong>lista collegata</strong>, con ogni blocco che ha un puntatore al blocco successivo, mentre l'ultimo blocco contiene un indicatore di fine file.
</p>
<p class='vspace'>Nella directory per ogni file memorizzo il 1° e l'ultimo blocco, così che si possano fare degli append rapidamente.
</p>
<p class='vspace'>Il vantaggio principale è che elimino la frammentazione esterna, perché posso usare teoricamente tutti i blocchi, in qualsiasi posizione essi si trovino.
</p>
<p class='vspace'>Ma il problema è l'accesso diretto: devo per forza partire dal primo blocco, va beh, ma poi devo seguire tutti i puntatori fino al punto che mi serve, e siccome la contiguità potrebbe non esserci, la testina potrebbe fare dei saltoni qua e là per il disco, che rallenterebbero la ricerca.
</p>
<p class='vspace'>Un SO furbo cercherà di allocare i blocchi di un file il più contigui possibile, ovviamente, oppure usare il concetto di <strong>cluster</strong>.
</p>
<p class='vspace'>Il <strong>cluster</strong> è un insieme di blocchi, e diventa lui l'unità minima di memorizzazione dei files. Un file riempie un cluster dietro l'altro, così almeno non si deve fare una nuova ricerca per ogni fine di blocco.
</p>
<p class='vspace'>Il cluster serve anche per ovviare al problema seguente: se un blocco a metà file si danneggia, come faccio a sapere qual'è il blocco successivo, visto che solo il blocco danneggiato contiene un puntatore a quel blocco?
</p>
<p class='vspace'>Se invece so che tutti i blocchi appartengono ad un cluster, male che vada perdo quel blocco, ma so che quello dopo appartiene ancora a quello stesso cluster.
</p>
<p class='vspace'>Occorre anche tenere in considerazione che i blocchi di un cluster <strong>non</strong> hanno tutti la stessa dimensione, perché di solito il primo contiene i riferimenti per puntare al cluster che logicamente lo segue. Questo complica un poco i calcoli per la scelta del blocco in funzione del record logico.
</p>
<div class='vspace'></div><h4>File Allocation Table (FAT)</h4>
<p>Si tratta sempre di allocazione collegata, ma stavolta si usa una <strong>tabella</strong>, che è esterna ai files, che viene memorizzata in blocchi noti a priori.
</p>
<p class='vspace'>Questa tabella contiene la lista dei blocchi di un file: il nome del file porta ad una voce in tabella, che contiene il numero di un blocco e il numero del blocco successivo (cioè della voce in tabella che lo rappresenta).
</p>
<p class='vspace'>In questo modo le ricerche avvengono in tabella e non in giro per il disco. Non c'è frammentazione esterna, ma se ho files grossi, la ricerca nella tabella può essere difficoltosa.
</p>
<div class='vspace'></div><h3>Allocazione indicizzata</h3>
<p>Introduco il concetto di <strong>i-node</strong>, ovvero <strong>index node</strong>: ogni file ha il suo i-node, che è un blocco che contiene la sequenza dei blocchi che compongono quel file. Per trovare l'n-esimo blocco, quindi, cerco l'n-esima voce nella lista dell'i-node.
</p>
<p class='vspace'>La contiguità qui è realizzata tramite l'i-node. Non c'è frammentazione esterna, l'accesso diretto è veloce anche se quello sequenziale un po' meno, ed è affidabile perché pur perdendo un blocco, il nodo mi sa dire qual'è quello successivo. E per evitare di perdere i nodi, ne tengo una copia.
</p>
<p class='vspace'>Il problema che balza all'occhio qui è che se un file ha bisogno di più blocchi di quanti non possano essere listati in un nodo, allora quel file non può essere creati.
</p>
<p class='vspace'>Ci sono quindi 3 sistemi diversi per superare questo ostacolo:
</p><ul><li><strong>blocco indice con schema collegato</strong>: l'ultima voce del nodo non porta ad un blocco ma ad un altro nodo. Semplice, ma se ho troppi nodi, le ricerche possono andare per le lunghe
</li><li><strong>blocco indice con indice multi-livello</strong>: metto tutto quanto in un albero, così il tempo di ricerca non è O(n) ma O(logn)
</li><li><strong>blocco indice con schema combinato</strong>: siccome a volte è inutile creare alberi per files piccoli, faccio una combo: un nodo ha un po' di entry che indicano direttamente blocchi (per files piccoli), altre entry che portano al primo livello dell'albero, e altre ancora che portano al terzo (ed eventualmente al quarto etc.). A seconda delle dimensioni del file, uso più o meno livelli.
</li></ul><div class='vspace'></div><h3>Miglioramento delle prestazioni per le allocazioni</h3>
<p>I sistemi sono fondamentalmente 2:
</p><ul><li>fare il <strong>caching</strong> delle informazioni relative ai files
</li><li><strong>read-ahead</strong>: leggo anticipatamente i blocchi, così che siano disponibili prima della richiesta. Il read-ahead è tanto più efficiente quanto più i blocchi sono fisicamente contigui.
</li></ul><div class='vspace'></div><h2>Gestione dello spazio libero</h2>
<p>Occorre anche trovare un modo per tener traccia dello spazio libero sul disco.
</p>
<div class='vspace'></div><h3>Vettore di bit</h3>
<p>Uso una mappa dei blocchi, in cui 1 bit indica se quel blocco è in uso o meno (qui ci sono versioni discordanti: 1 = in uso, 0 = vuoto o viceversa? Va beh, non cambia niente).
</p>
<p class='vspace'>Non importa da chi è stato usato quel blocco, ai fini dello spazio libero importa solo che non sia utilizzabile
</p>
<p class='vspace'>Quando voglio salvare un file, devo trovare nella mappa lo spazio contiguo adatto a contenerlo, se so in anticipo le dimensioni. Per evitare di sprecare gli spazi contigui ampi, uso il più piccolo spazio contiguo che può contenere il file.
</p>
<p class='vspace'>Questo approccio funziona bene se è gestito in hardware (?).
</p>
<div class='vspace'></div><h3>Lista collegata</h3>
<p>Mantengo una lista collegata dei blocchi liberi. Si può usare una roba del genere coi diversi tipi di allocazione, perché in fondo è come se fosse un file particolare.
</p>
<p class='vspace'>Il problema è che i gruppi di blocchi vuoti contigui non sono immediatamente riconoscibili: occorre scandire la lista e controllare blocco per blocco la contiguità.
</p>
<div class='vspace'></div><h3>Raggruppamento</h3>
<p>Memorizzo l'indirizzo del primo blocco di una serie di blocchi contigui, e il numero di blocchi vuoti che lo seguono.
</p>
<p class='vspace'>Tengo traccia di questa lista, che può anche essere separata dal resto del FS, e ad essa attingo durante le mie ricerche.
</p>
<p class='vspace'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 5 - Valutazione dell'efficienza e delle prestazioni</strong></span>
</p>
<p class='vspace'  style='text-align: center; background-color: red; border: 3px dotted yellow; padding: 3px;'><span  style='color: white;'><strong>Lezione un po' confusa...</strong></span>
</p>
<p class='vspace'>L<strong>'efficienza</strong> riguarda l'uso delle risorse. Le <strong>prestazioni</strong> riguardano la velocità.
</p>
<div class='vspace'></div><h3>Efficienza</h3>
<p>Per migliorare l'efficienza, devo tenere conto di vari parametri, come le dimensioni dei blocchi, dei puntatori ai blocchi e dei metadati. Questo mi può dire quanto spazio spreco per memorizzare tot dati.
</p>
<p class='vspace'>La dimensione dei blocchi deve essere tale da ridurre le frammentazioni esterna ed interna, e ridurre lo spazio usato per la gestione internamente ad ogni blocco.
</p>
<p class='vspace'>Per migliorarla, potrei usare dei cluster di dimensioni non uguali ma variabili a seconda delle dimensioni del file. La FAT, se uso quella, sarebbe più grossa, ma ridurrei gli sprechi.
</p>
<div class='vspace'></div><h3>Prestazioni</h3>
<p>Per migliorare le prestazioni, oltre all'utilizzo della cache, dovrei usare algoritmi semplici e strutture dati a cui si possa accedere velocemente.
</p>
<p class='vspace'>Un esempio di miglioramento delle prestazioni si ha quando metto in memoria centrale la tabella degli i-node, così che sia rapidamente accessibile.
</p>
<div class='vspace'></div><h3>Supporti hardware dedicati</h3>
<ul><li>cache del disco in memoria centrale, ma anche direttamente sul disco (e che vuol dire?)
</li><li>cache delle pagine in memoria centrale
</li></ul><p class='vspace'>Vediamo di chiarire il discorso cache, che è piuttosto nebuloso.<br />I dischi fissi hanno al proprio interno una cache, ovviamente gestita in proprio: quando il SO vuole un blocco, se questo è in cache il disco gli dà quello ed evita di muovere la testina. Questa cache contiene interi settori.
</p>
<p class='vspace'>Alcuni sistemi hanno la <strong>cache del disco</strong>, dove cachano i <strong>blocchi</strong>: se mi serve ancora, lo pesco dalla cache e non dal disco. Niente di nuovo.
</p>
<p class='vspace'>Altri sistemi invece di cachare i blocchi, <strong>cachano le pagine</strong>: usano lo stesso gestore della memoria virtuale, ma invece di metterci le pagine dei processi, nei frames ci mettono i pezzi di blocco. Il libro sostiene che "memorizzare i dati del file tramite indirizzi virtuali è più efficiente che nemmeno memorizzarli con i blocchi fisici del disco". La sintassi di questa frase non lascia capire se:
</p><ul><li>ricercare un pezzo di file tramite indirizzo virtuale è più veloce che nemmeno ricercarlo per numero di blocco
</li><li>utilizzare la memoria virtuale per fare questo mestiere è più veloce che usare una cache separata
</li></ul><p class='vspace'>A quanto pare, il paragrafo successivo <strong>ripete</strong> quanto detto qui sopra, chiamandolo <strong>memoria virtuale unificata</strong>.
</p>
<p class='vspace'>Aggiunge poi la nota che Solaris invece usa <strong>due cache</strong> diverse: quella del blocco per cachare i <strong>metadati del filesystem</strong>, che sono gli i-node e le varie strutture dati del FS; poi usa anche la cache di pagina per i <strong>dati effettivi</strong> di ogni singolo file.
</p>
<p class='vspace'>Il pezzo succcessivo lo interpreto così: c'è un modo che <strong>non</strong> abbiamo contemplato, riguardante l'apertura dei files: la mappatura in memoria. Vuol dire che per accedere ad un file, <strong>non</strong> specifico un blocco, bensì un <strong>indirizzo di memoria</strong>, e ci pensa poi il SO a capire che quell'indirizzo è stato mappato ad un file e non ad un indirizzo di memoria centrale. Un po' quello che succede con le periferiche I/O mappate in memoria.<br />Successivamente, occorre ricordarsi della <strong>semantica della copia</strong>, che mi diceva che le I/O vengono effettuate in un <strong>buffer</strong> per velocizzarle, e poi il buffer viene flushato asincronicamente sul disco.<br />Orbene: se uso <strong>contemporaneamente</strong> questi due sistemi, la prima cosa da notare è che il <strong>buffer</strong> viene <strong>prima</strong> di tutto il resto: ciò vuol dire che le mie I/O vengono prima fatte nel buffer, e poi il buffer viene flushato.<br />Ma qui sorge il problema: se flusho sul disco, ok, ma se flusho su un file mappato in memoria, vuol dire che i dati che escono dal buffer devono passare dalla cache della memoria virtuale, ed infine trasferiti sul disco. Ciò implica uno spreco di tempo, ed ha anche un nome proprio: <strong>double caching</strong>.<br />Per evitare ciò, si usa la <strong>buffer cache unificata</strong>, il che vuol dire che la memoria virtuale realizza tutto, sia i files mappati in memoria che la I/O bufferizzata.
</p>
<p class='vspace'>Ad ogni modo, avere più di una cache vuol dire sincronizzarle tutte, e sincronizzare infine col disco. La cache, usata per mediare l'I/O, lo rende più efficiente, soprattutto se mi permette di schedulare bene le richieste, così da muovere il meno possibile la testina in giro per il disco.
</p>
<p class='vspace'>Però, sopravviene il problema delle scritture asincrone: se un processo scrive qualcosa, e riceve il segnale di "TUTTO OK" quando la scrittura è terminata solo in memoria centrale ma non ancora sul disco, un guasto che accadesse immediatamente dopo avrebbe come conseguenza il fatto che sul disco non è stato scritto niente, anche se al processo risulta diversamente. Allora, in genere per i dati critici si usa la scrittura sincrona.
</p>
<p class='vspace'>Poi, parlando della memoria virtuale unificata, compare il <strong>disco virtuale</strong>, gestito come un FS, ma risiedente direttamente in memoria centrale, con tutti i vantaggi (velocità) e svantaggi (se tolgo la corrente perdo tutto) del caso.
</p>
<p class='vspace'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 6 - Manutenzione del FS</strong></span>
</p>
<p class='vspace'>Ci possono essere errori nel FS, che non riguardano i dati, ma le strutture di gestione del FS stesso. Possono essere dovuti ad errori fisici nel disco, oppure ad errori di scrittura nel FS da parte del SO.
</p>
<p class='vspace'>Il risultato è che il FS perde la sua <strong>coerenza</strong>: il controllore della coerenza è quello che fa il check del FS, per controllare che dati e metadati parlino della stessa roba.
</p>
<div class='vspace'></div><h3>Backup e ripristino</h3>
<p>Il concetto di <strong>backup</strong> mi dice che posso poter accettare di perdere parte delle modifiche, pur di tornare ad uno stato coerente del FS.
</p>
<p class='vspace'>L'idea è di creare, periodicamente, delle <strong>copie di backup</strong> del FS, quando esso è in uno stato consistente, cioè dati e metadati sono a posto.
</p>
<p class='vspace'>Il backup completo consiste nel salvare ogni volta tutto quanto. Quello incrementale invece salva solo le modifiche relative all'ultimo backup completo.
</p>
<p class='vspace'>Il ripristono (<strong>restore</strong>) avviene diversamente, nei due casi. Se ho il backup completo, prendo l'ultimo backup e lo copio. Nel caso di quello incrementale, prima copio l'ultimo backup completo, poi applico tutti i backup incrementali che trovo.
</p>
<p class='vspace'>Le copie di backup devono comunque essere tenute anche fisicamente al sicuro.
</p>
<p class='vspace'>Nei <strong>FS orientati alle transazioni</strong>, c'è un log delle transazioni come per le basi di dati, che permette di recuperare eventuali errori.
</p>
<p class='vspace'>Nei <strong>FS con journaling</strong> c'è un journal, un diario, che tiene traccia di tutte le attività svolte.
</p>
<p class='vspace'  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'><strong>:: Protezione ::</strong>
</p>
<p class='vspace'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 1 - Concetti fondamentali della protezione</strong></span>
</p>
<p class='vspace'>Il <strong>dominio di protezione</strong> è il concetto generale, mentre tutto il resto sono implementazioni dello stesso.
</p>
<p class='vspace'>Si vuole avere protezione da accessi indebiti (cioè da chi non dovrebbe accedere) e errati. Bisogna poter definire che cosa si può fare con le risorse.
</p>
<p class='vspace'>Al solito, abbiamo <strong>regole</strong>, cioè le politiche per decidere chi e come può usare le risorse, e <strong>meccanismi</strong>, ovvero come implementare suddette regole.
</p>
<p class='vspace'>Le risorse di cui parliamo sono sia fisiche che informative, e sono tutte identificabili con un id. Ci sono poi delle operazioni che si possono svolgere su queste risorse.
</p>
<p class='vspace'>Il <strong>principio di minima conoscenza</strong> dice che un processo deve avere i minimi permessi necessari al suo funzionamento, niente di più.
</p>
<p class='vspace'>Il <strong>dominio di protezione</strong> definisce un insieme di risorse e le relative operazioni lecite per un processo autorizzato ad accedere al dominio.
</p>
<p class='vspace'>Il processo che entra in un dominio vede solo le operazioni e le risorse associate a quel dominio.
</p>
<p class='vspace'>Questo insieme assume l'aspetto di un insieme di coppie del tipo <strong>&lt;oggetto, diritto&gt;</strong>. Ci possono anche essere intersezioni tra i vari domini, il che è anche abbastanza intuitivo.
</p>
<p class='vspace'>Come si associano i processi ai domini? Dicevamo qui sopra che un processo deve <strong>entrare</strong> in un dominio, e vedere solo le cose che il dominio gli permette di vedere. L'assegnazione di un processo ad un dominio può essere <strong>statica</strong> o <strong>dinamica</strong>.
</p>
<p class='vspace'>Se è statica, il processo entra in un dominio e vi rimane fino alla morte.<br />Se è dinamica, invece, può cambiare da un dominio all'altro durante la sua vita, ovviamente se dispone delle autorizzazioni necessarie.
</p>
<p class='vspace'>Quindi, pensandoci bene, se devo avere le autorizzazione anche per cambiare di dominio, allora il dominio stesso è concepibile come una risorsa, cioè un oggetto a cui applicare dei permessi! Vuol dire che ad ogni dominio può essere associato un permesso su di un altro dominio, che potrebbe essere quello di accedervi, oppure quello di modificarne i contenuti.
</p>
<p class='vspace'>Oltre che essere concessi, i diritti di accesso ad un processo possono venir <strong>revocati</strong>. La revoca può essere:
</p><ul><li><strong>immediata</strong> o <strong>ritardata</strong>. Se è ritardata, si può attendere o la morte del processo o altri eventi
</li><li><strong>selettiva</strong> o <strong>generale</strong>: riguarda o no tutti i processi in quel dominio
</li><li><strong>totale</strong> o <strong>parziale</strong>: revoco alcuni diritti, oppure tutti
</li><li><strong>temporanea</strong> o <strong>permanente</strong>
</li></ul><p class='vspace'>Infine, se voglio avere delle regole specifiche per un singolo processo, occorre avere un dominio in cui l'unico autorizzato ad entrarvi sia proprio quel processo.
</p>
<p class='vspace'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 2 - Realizzazione</strong></span>
</p>
<p class='vspace'>Qui vediamo come realizzare i domini di protezione.
</p>
<div class='vspace'></div><h3>Matrice degli accessi</h3>
<p>La <strong>matrice degli accessi</strong> è una tabella le cui righe sono i domini, e le colonne sono le risorse. L'incrocio tra una riga ed una colonna, cioè una cella, mi dice che cosa quel dominio può fare a quella risorsa.
</p>
<p class='vspace'>Come dicevamo prima, i domini sono anche delle risorse, quindi avremo i domini anche tra le colonne.
</p>
<p class='vspace'>L'operazione di cambio di dominio si chiama <strong>switch</strong>.
</p>
<p class='vspace'>Quando viene eseguito uno switch, può esserci o meno il <strong>diritto di copia</strong>, ovvero copiare i permessi da un dominio all'altro, così che il processo li ha tutti e due.
</p>
<p class='vspace'>Alternativamente, posso implementare il <strong>diritto di proprietà</strong>, che limita il diritto di copia ai soli casi in cui il processo sia proprietario di quella risorsa.
</p>
<p class='vspace'>La matrice degli accessi è un concetto astratto, che rappresenta tutto quello che mi serve relativamente ai domini di protezione. Poi, però, devo anche rappresentarla fisicamente.
</p>
<div class='vspace'></div><h4>Matrice completa</h4>
<p>Semplicemente, disegno l'intera matrice degli accessi. Il problema è che è una <strong>matrice sparsa</strong>, ovvero avrà un sacco di celle vuote, e soprattutto sarà immensa.
</p>
<div class='vspace'></div><h4>Lista di controllo degli accessi</h4>
<p>Invece di memorizzare la matrice completa, salvo solamente le <strong>colonne</strong>.
</p>
<p class='vspace'>Per ogni risorsa, c'è una lista di coppie &lt;dominio, permessi&gt;.
</p>
<p class='vspace'>Così facendo, faccio alla svelta a modificare i diritti relativi ad una risorsa: scorro la lista e applico le dovute modifiche. Al contrario, se voglio aggiungere o eliminare dominî, devo scandire tutte le liste di tutte le risorse.
</p>
<p class='vspace'>Nei sistemi grandi, sono poco efficienti perché le risorse saranno tantissime.
</p>
<div class='vspace'></div><h4>Lista delle capacità</h4>
<p>Memorizzo le <strong>righe</strong> della matrice degli accessi. Avrò quindi una lista &lt;risorsa, permessi&gt;.
</p>
<p class='vspace'>Rispetto alla lista di controllo degli accessi, la modifica ad una risorsa implica il traversamento di tutte le liste, mentre le modifiche ad un dominio riguardano solo quella lista.
</p>
<p class='vspace'>Le revoche diventano altamente inefficienti, perché devo cercare la risorsa in tutte le liste.
</p>
<div class='vspace'></div><h4>Lock-key</h4>
<p>L'idea è: se un processo ha la chiave, esegue l'operazione. Ad ogni risorsa viene assegnato un lucchetto, che può anche essere uguale, e ad ogni processo una chiave, o più di una. Quando un processo vuole accedere ad una risorsa, deve controllare se la sua chiave funziona con quel lucchetto.
</p>
<div class='vspace'></div><h3>Amenità varie</h3>
<p>Ci sono SO basati sulle liste di capacità.
</p>
<p class='vspace'>Ci sono protezioni basati sul linguaggio di programmazione, in cui
</p><ul><li>il programmatore
</li><li>il progettista
</li><li>l'amministratore
</li></ul><p>danno i permessi ad un processo già in fase di compilazione. Però la sicurezza è inferiore.
</p>
<p class='vspace'><a class='wikilink' href='SistemiOperativi.html'>Torna alla pagina di Sistemi Operativi</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/Piuri5Maggio2008)</span></div>
  </div>
</body>
</html>
