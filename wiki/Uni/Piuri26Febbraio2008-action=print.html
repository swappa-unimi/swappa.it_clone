<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Sistemi Perativi: Appunti del 26 febbraio 2008</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='Piuri26Febbraio2008.html' title='Sistemi Perativi: Appunti del 26 febbraio 2008'>Sistemi Perativi: Appunti del 26 febbraio 2008</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
</p><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: Sistemi Perativi: Appunti del 26 febbraio 2008 ::</strong>
</pre><p class='vspace'><a class='wikilink' href='SistemiOperativi.html'>Torna alla pagina di Sistemi Perativi</a>
</p>
<p class='vspace'  style='text-align: center;'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 3</strong></span>
</p>
<p class='vspace'  style='text-align: center;'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>La Memoria</strong></span>
</p>
<p class='vspace'>La memoria la si può vedere organizzata gerarchicamente. Partiamo dall'alto e scendiamo verso il basso.
</p>
<div class='vspace'></div><h3>Registri</h3>
<p>Sono realizzati all'interno della CPU. Hanno dimensioni ridotte, in genere pari alla lunghezza della word del processore (eg, un processore a 32 bit ha tipicamente registri di 32 bit, uno a 16 bit ne avrà a 16 bit, la macchina MixAL ovviamente fa casino).
</p>
<p class='vspace'>Non sono molti, da una manciata ad un max di un centinaio. Ma sono veramente veloci.
</p>
<div class='vspace'></div><h3>Cache</h3>
<p>La <strong>cache di primo livello</strong> è costruita all'interno del processore. Quella di <strong>secondo livello</strong> appena fuori. Sono più lente dei registri, ma anche più capienti.
</p>
<p class='vspace'>Servono per copiarci la zona di memoria centrale su cui il processore sta lavorando attualmente. In questo modo può leggere e scrivere in modo molto veloce senza passare per i BUS etc. etc. Occorre stare attenti alla coerenza della memoria: se scrivo in cache e non nella porzione di memoria centrale corrispondente, allora quando svuoto la cache devo aggiornare anche la memoria centrale, se no si creano discrepanze e tutto va a ramengo. Tutto ciò viene fatto dall'hardware.
</p>
<div class='vspace'></div><h3>Memoria centrale</h3>
<p>Secondo Fonnoiman, vi metto dati e programmi. Più ampia, molto più ampia della cache, è anche più lenta di un ordine di grandezza.
</p>
<p class='vspace'>Occorre precisare che il processore è in grado solo di leggere roba dalla memoria centrale. L'esistenza della cache è un trucco tecnologico, al processore sembrerà comunque di leggere dalla memoria centrale, non ha nozione dell'esistenza della cache. Semplicemente, se un certi chippettino si accorge che l'indirizzo di memoria voluto dal processore è in cache, evita di scomodare i bus e glielo fornisce seduta stante. Ma il processore di ciò non sa nulla.
</p>
<div class='vspace'></div><h3>Memoria di massa</h3>
<p>La memoria centrale è ampia ma mai abbastanza. Quindi ci sono diverse tipologie di memoria di massa che, pur essendo molto più lente, hanno molto spazio a basso costo. Dischi magnetici, ottici, nastri, memorie flash e così via sono tipi di memoria di massa.
</p>
<div class='vspace'></div><h3>Protezione della memoria</h3>
<p>Se il mio calcolatore ha un solo programma in memoria, questo è padrone di tutte le risorse del computer. Ma se ne ho due, nessuno dei due è più il Signore dei Byte. Ogni programma deve girare nella sua brava porzione di memoria e non scomodare quelle altrui, se no immaginate quanti casini. Quindi, c'è un'unità chiamata <strong>MMU</strong>, ovvero <strong>Mia Moglie Uccide</strong>, oppure <strong>Memory Management Unit</strong>, che contiene l'indirizzo iniziale e quello finale dell'area di memoria che un certo programma può usare o no. Se la CPU sconfina, ovvero chiede un'indirizzo di memoria fuori da quest'area, viene notificato un errore. È il sistema operativo che informa la MMU dei limiti della memoria, visto che il processore non sa niente di programmi ma si limita ad eseguire le sue fasi in sequenza.
</p>
<p class='vspace'>La protezione dei registri e della cache è implicita nel cambio di contesto: tutto viene salvato nello stack e lo si ripiglia dopo, e la cache si riempie a seconda di ciò che il processore vuole.
</p>
<p class='vspace'>La protezione nelle memorie di massa è realizzata dal file system. È il file system a decidere se qualcuno sta scrivendo su di un file dove non dovrebbe, o sta accedendo a zone del disco fisso che gli sono vietate.
</p>
<p class='vspace'  style='text-align: center;'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 4</strong></span>
</p>
<p class='vspace'  style='text-align: center;'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Connessione delle periferiche</strong></span>
</p>
<p class='vspace'>Le periferiche non sono connesse direttamente alla CPU, ma tra questa e le periferiche ci sono degli opportuni gestori. Il vantaggio di avere i gestori è che posso modificare le periferiche, aggiornare gli standard per comunicarci etc. ma lasciare uguale l'interfaccia del gestore che la CPU vede.
</p>
<p class='vspace'>L'interfaccia è composta da 2 parti:
</p><ol><li>gestore che comunica direttamente con il processore. Riceve comandi ed invia dati
</li><li>parte elettronica che comunica con la periferica, generando segnali elettrici etc.
</li></ol><p class='vspace'>Anche presso la periferica ci sono 2 parti:
</p><ol><li>parte che comunica con la periferica stessa, eg il chip che in un disco fisso alza e abbassa il braccio etc.
</li><li>parte che comunica con il gestore del sistema
</li></ol><p class='vspace'>Tra periferica e gestore di periferica ci può essere una connessione USB, seriale, parallela, PS2, PCI etc.
</p>
<div class='vspace'></div><h3>Interfaccia nell'unità centrale</h3>
<p>Tra CPU e interfaccia c'è un bus. L'interfaccia presenta tree registri: un <strong>registro di stato</strong>, un <strong>registro comandi</strong> ed un <strong>registro dati</strong>.
</p>
<p class='vspace'>Il registro di stato viene letto dalla CPU. In questo modo la CPU sa se la periferica è occupata, rotta, connessa e così via.
Il registro comandi viene scritto dalla CPU, e contiene i comandi che la CPU invia all<em>'interfaccia</em>.
Il registro dati viene scritto dalla CPU e contiene i comandi che la CPU invia alla <em>periferica</em>.
</p>
<p class='vspace'>Quindi, è l'interfaccia che pensa a inviare ciò che legge nel registro dati alla periferica, e a restituire ciò che la periferica risponde al registro di stato, così che la CPU possa leggerlo. NON succede che la CPU scrive i <em>dati</em> che vuole mandare alla periferica nel registro dati, generalmente, bensì colà vi scrive i comandi.
</p>
<p class='vspace'>È la periferica poi ad eseguire i comandi e a rispondere all'interfaccia.
</p>
<p class='vspace'>La CPU deve trovare il momento in cui la periferica sia disponibile. Può farlo in 2 modi:
</p><ol><li>attesa passiva: la CPU si mette in attesa che lo stato della periferica sia disponibile
</li><li>interruzione: la CPU dà l'ordine, e quando la periferica esegue risponde con un'interruzione, così che la CPU possa rendersi conto di ciò che è successo.
</li></ol><p class='vspace'>Lo svantaggio dell'attesa passiva è che mentre la CPU attende, non può fare altro, e si perde tempo.
</p>
<p class='vspace'>Il trasferimento dei dati tra CPU e periferica può <em>anche</em> avvenire con il registro dati, ma è limitato e poco efficiente. Per questo si è inventato il <strong>DMA</strong>, ovvero <strong>Direct Memory Access</strong>, cioè un affare che gestisce in modo autonomo il trasferimento di blocchi di dati dalla memoria centrale alla periferica, senza scomodare nessun altro.
</p>
<p class='vspace'>Un altro modo per ottenere questa comunicazione è mappare la periferica in una zona dello spazio di indirizzamento. In pratica, organizzo il mio sistema in modo tale che alcuni indirizzi di memoria non portino alla memoria centrale, ma siano "deviati" verso una certa periferica. In questo modo alla CPU sembrerà di scrivere in memoria, ma in realtà sta scrivendo in periferica.
</p>
<p class='vspace'  style='text-align: center;'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 5</strong></span>
</p>
<p class='vspace'>Va beh qui si parla di reti ma non si dice molto di interessante, quindi non scrivo niente.
</p>
<p class='vspace'  style='text-align: center;'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 6</strong></span>
</p>
<p class='vspace'  style='text-align: center;'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Classificazione dei sistemi di elaborazione</strong></span>
</p>
<p class='vspace'>Questa lezione è una specie di excursus storico - funzionale sui tipi di sistema di elaborazione. Niente di fondamentale.
</p>
<div class='vspace'></div><h3>Mainframe</h3>
<p>Un computerone grande e grosso e costoso, tipico degli anni 60, che esegue un lavoro, detto <strong>job</strong>, alla volta. Eseguire un job alla volta vuol dire lavorare a <strong>batch</strong>, cioè a lotti: eseguo il mio lotto, poi faccio il successivo. 
Si tratta quindi di un sistema monoprogrammato, in cui la macchina esegue un programma, e quando questo finisce se ne esegue un altro..
</p>
<p class='vspace'>Siccome così si sprecavano tempo e risorse, si è inventata la <strong>multiprogrammazione</strong>: la macchina tiene in memoria contemporaneamente più programmi, e quindi non c'è la perdita di tempo di mandare l'omino a caricarne uno nuovo ogni volta con le schede perforate che si usavano a Bedrock (<em>"Wilma, dammi la schedaaaaa!!!"</em>).
</p>
<p class='vspace'>Nemmeno questa soluzione è sufficiente per ottimizzare le spese, quindi si passa alla <strong>condivisione CPU</strong>, in cui la CPU esegue contemporaneamente più programmi. Un altro modo per chiamare ciò è <strong>multiprocessing</strong>. La cosa balorda del multiprocessing è che si passa da un processo all'altro quando il primo è in un tempo morto, eg aspettando dell'input da parte di Fred Flinstone. Se un processo fa qualcosa di oneroso, gli altri si attaccano ed aspettano.
Quando si sono inventati i sistemi multiutente, con i terminali in giro per l'edificio, capitava che il programma in esecuzione su di un terminale bloccasse gli altri, utilizzando questa tecnica di multitasking.
</p>
<p class='vspace'>Ecco quindi che si passa al <strong>time sharing</strong>, ovvero si stabilisce che un processo, qualsiasi cosa faccia, usi la CPU per un certo periodo di tempo e poi passi il testimone al processo dopo. Così, tutti gli utenti hanno l'impressione che la macchina sia dedicata a loro. Quando, come e perché cambiare processo attivo è una specie di magia nera, cmq, ma vedremo più in là.
</p>
<div class='vspace'></div><h3>Minicomputer</h3>
<p>È una versione per piccoli gruppi dei mainframe. Non è ancora un sistema monoutente, perché non c'è ancora convenienza, ma siamo su quella strada. Da qui in poi si assume che tutti i sistemi siano chi più chi meno multiprogrammati, multiprocessing e time sharing.
</p>
<div class='vspace'></div><h3>Workstation</h3>
<p>Anni 80: soddisfa le esigenze avanzate di un singolo utente. Eg una workstation grafica dedicata al CAD, o alla grafica 3D.
</p>
<div class='vspace'></div><h3>Personal Computer</h3>
<p>Il terminale del mainframe acquisisce vita autonoma e capacità di calcolo in proprio. Non esagerate, ma abbastanza per i bisogni del singolo utente.
</p>
<div class='vspace'></div><h3>Palmare</h3>
<p>bla bla bla
</p>
<div class='vspace'></div><h3>Sistemi di elaborazione in tempo reale</h3>
<p>Apparecchi industriali, divisibili a loro volta in <strong>hard real time</strong> e <strong>soft real time</strong>, sul cui significato si indagherà più in là.
</p>
<div class='vspace'></div><h3>Sistema dedicato</h3>
<p>Fa 1 e 1 sola cosa. Eg il software di John Waine: o cammina o mastica la gomma.
</p>
<div class='vspace'></div><h3>Sistemi multimediali</h3>
<p>Hanno cose avanzate per il multimedia bla bla blabaorum.
</p>
<div class='vspace'></div><h3>Sistemi multiprocessore</h3>
<p>Invece di fare un processure suppauppa, ne prendo un po' e li faccio lavorare insieme. Il sistema è <strong>simmetrico</strong> se tutti i processori sono equivalenti a livello di capacità, ovvero possono fare tutti lo stesso tipo di lavoro (eg avere 2 o 4 processori pentium sulla scheda madre). Se invece ho processori dedicati ad uno scopo particolare, allora il sistema è asimmetrico (eg ho un processore generico e uno dedicato al download di porno da internet).
</p>
<div class='vspace'></div><h3>Cluster</h3>
<p>Un altra versione del sistema multiprocessore, in cui però non ho più processori sulla stessa scheda, ma più processori in macchine diverse, connesse tramite hardware performante.
</p>
<div class='vspace'></div><h3>Sistema distribuito</h3>
<p>Ulteriore generalizzazione del multiprocessore. Si tratta di un cluster in cui l'hardware di interconnessione è quello standard di rete. In questo modo, prendo letteralmente macchine normali e le faccio lavorare insieme quando serve.
</p>
<p class='vspace'><a class='wikilink' href='SistemiOperativi.html'>Torna alla pagina di Sistemi Perativi</a>
</p>
<div class='vspace'></div>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/Piuri26Febbraio2008)</span></div>
  </div>
</body>
</html>
