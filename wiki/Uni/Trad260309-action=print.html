<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Traduttori - Appunti del 26 marzo 2009</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='Trad260309.html' title='Traduttori - Appunti del 26 marzo 2009'>Traduttori - Appunti del 26 marzo 2009</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
</p>
<p class='vspace'><a class='wikilink' href='Traduttori.html'>Torna alla pagina di Traduttori</a>
</p>
<p class='vspace'  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'><strong>:: Traduttori - Appunti del 26 marzo 2009 ::</strong>
</p>
<div class='vspace'></div><h2>FA e Regexp</h2>
<p>Dopo aver a lungo blaterato sugli automi, vogliamo ora dimostrare che essi sono equivalenti alle espressioni regolari. In termini matematici, quello che vogliamo dimostrare è che
</p><pre> L(A) = L(R), con gli L definiti sullo stesso alfabeto
</pre><div class='vspace'></div><h3>Intuitivamente, si fa così</h3>
<p>Prendiamo questo automa:
</p>
<div class='vspace'></div><div><span class='frame rfloat'><img src='../uploads/Uni/trad-a-re.png' alt='' title='' /></span></div>
<p class='vspace'>Le trasformazioni intuitive sono queste:
</p><ul><li>quando ho diversi archi uscenti da uno stato, allora nella regexp equivalente avrei un<strong>'alternativa</strong>, cioè un <strong>+</strong>
</li><li>il cammino singolo da uno stato ad un altro è la <strong>concatenazione</strong>
</li><li>un loop è l'operatore <strong>*</strong>
</li></ul><p class='vspace'>Possiamo dire che ogni cammino che va dallo stato iniziale ad uno finale viene espresso tramite una regexp, e che poi tutte queste regexp vengono messe in alternativa l'una con l'altra. Un sistema un po' brutale, ma funziona.
</p>
<p class='vspace'><br clear='all' />
</p><h3>Induttivamente, invece, si fa così</h3>
<p>Più matematicamente, per ottenere la mia trasformazione da FA a regexp, dobbiamo utilizzare i seguenti concetti:
</p><ul><li><strong>|Q<sub>A</sub>| = n</strong>, il che vuol dire che l'insieme degli stati del mio automa <strong>A</strong> li etichetto con dei numeri interi, e questo trucco mi serve per avere comodità a fare certe cose
</li><li><strong>R<sup>(k)</sup><sub>i,j</sub></strong> è la regexp che descrive tutte le stringhe <strong>w</strong> tali che <strong>w</strong> è contenuta nel cammino che va dallo stato <strong>i-esimo</strong> allo stato <strong>j-esimo</strong> (ecco perché li abbiamo appena numerati, così possiamo riferirci a loro con dei numeri). In pratica, questa regexp rappresenta il sotto-automa che parte dallo stato <strong>i</strong> ed arriva allo stato <strong>j</strong>, ed in più ho la condizione che gli stati intermedi di questo cammino avranno <strong>tutti</strong> un indice <strong>minore di k</strong>.
</li></ul><p class='vspace'>Ricapitolando: ho preso tutti gli stati, e li ho numerati da 1 ad <strong>n</strong>. Poi, ho definito la generica regexp <strong>R<sup>(k)</sup><sub>i,j</sub></strong> dicendo che rappresenta la porzione di automa che va da <strong>i</strong> a <strong>j</strong>, e che in questa strada non passa per stati che nella mia numerazione hanno un indice maggiore di <strong>k</strong>.
</p>
<p class='vspace'>A che cosa mi serve il vincolo su <strong>k</strong>? Il suo scopo è unicamente permettermi di definire induttivamente la <strong>R</strong>, in modo piuttosto semplice. Non c'è una profonda verità matematica o logica, è solo un escamotage per facilitarmi nella dimostrazione dell'equivalenza.
</p>
<p class='vspace'><strong>Caso base:</strong> k = 0<br />Per come ho appena definito il vincolo su <strong>k</strong>, dire che <strong>k = 0</strong> vuol dire <em>non si deve passare per stati intermedi che abbiano indice &gt; k</em>. Ma k = 0, e quindi <strong>non ci sono stati intermedi</strong>.
</p>
<p class='vspace'>Sono due le occasioni in cui non ho stati intermedi:
</p><ol><li><strong>j</strong> segue immediatamente <strong>i</strong>: i -&gt; j, e non ci sono stati intermedi
</li><li><strong>i</strong> coincide con <strong>j</strong>, e a maggior ragione non ci sono stati intermedi.
</li></ol><p class='vspace'>Se <strong>j</strong> segue immediatamente <strong>i</strong>, allora come è definita la <strong>R<sup>(0)</sup><sub>i,j</sub></strong>? Beh, dipende:
</p><ul><li>se non c'è nessun carattere <strong>a</strong> che porta da <strong>i</strong> a <strong>j</strong>, allora <strong>R<sup>(0)</sup><sub>i,j</sub> = &#8709; </strong>
</li><li>se esiste <strong>un solo carattere a</strong> che porta da <strong>i</strong> a <strong>j</strong>, allora <strong>R<sup>(0)</sup><sub>i,j</sub> = a</strong>, molto banalmente
</li><li>se esistono <strong>diversi a</strong> che mi conducono da <strong>i</strong> a <strong>j</strong>, allora altrettanto banalmente ho <strong>R<sup>(0)</sup><sub>i,j</sub> = a<sub>1</sub> + a<sub>2</sub> + a<sub>3</sub> + ... a<sub>r</sub></strong>
</li></ul><p class='vspace'>Ricordate che sopra abbiamo detto che, intuitivamente, diversi archi uscenti diventano un'alternativa? Ecco, questa qui sopra ne è la dimosstrazione.
</p>
<p class='vspace'>Se invece <strong>i = j</strong>, allora com'è invece la <strong>R<sup>(0)</sup><sub>i,j</sub></strong>?<br />La prima cosa da dire è che le regole qui sopra valgono ugualmente, perché non c'è nessuna controindicazione.
</p>
<p class='vspace'>Tuttavia, di tutte le possibili eventualità, manca quella in cui non c'è nessun arco uscente. In questo caso, dovrei dire che
</p><pre> <strong>R<sup>(0)</sup><sub>i,j</sub> = &#8709; + &#949;</strong>
</pre><p class='vspace'>Ma allora riformulo anche le altre includendo l'eventualità della stringa &#949;, e dico pertanto che
</p><ul><li>nel caso di un solo arco uscente, ho <strong>R<sup>(0)</sup><sub>i,j</sub> = a + &#949;</strong>
</li><li>nel caso di più archi uscenti ho <strong>R<sup>(0)</sup><sub>i,j</sub> = a<sub>1</sub> + a<sub>2</sub> + a<sub>3</sub> + ... a<sub>r</sub> + &#949;</strong>
</li></ul><p class='vspace'>Ho quindi un bel caso base da cui partire.
</p>
<p class='vspace'><strong>Passo induttivo:</strong> R<sup>(k)</sup><sub>i,j</sub> con k &#8800; 0<br />Anche in questo caso devo sdoppiare la mia dimostrazione:
</p><ol><li>posso infatti passare per <strong>nessuno stato k</strong>
</li><li>oppure passare per <strong>uno o più stati k</strong>
</li></ol><p>Chiamo "stati k" gli stati con indice maggiore di k bla bla bla.
</p>
<p class='vspace'>Se non passo per nessuno stato <strong>k</strong>, allora vuol dire che tutti gli stati che attraverso avranno indice minore di <strong>k</strong>. Posso allora dire che:
</p><pre> R<sup>(k)</sup><sub>i,j</sub> = R<sup>(k-1)</sup><sub>i,j</sub>
</pre><p>proprio perché posso abbassare la "soglia".
</p>
<p class='vspace'>Se invece passo per uno o più stati k, avrei una situazione di questo tipo:
</p><pre> i -&gt; ... -&gt; k -&gt; ... k-&gt; ... -&gt; j
</pre><p>dove i tre puntini <strong>...</strong> dicono che c'è una successione di stati non meglio identificati.
</p>
<p class='vspace'>Ho quindi due cammini: uno che va da <strong>i</strong> a <strong>k</strong>, e l'altro che va da <strong>k</strong> a <strong>j</strong>.<br />Che cosa succede alla parte in mezzo? Anche qui posso duplicare la risposta:
</p><ol><li>posso avere una sola occorrenza di stati <strong>k</strong>
</li><li>posso avere diverse occorrenze di stati <strong>k</strong>
</li></ol><p class='vspace'>Ricapitolando, il cammino che va da <strong>i</strong> a <strong>j</strong>, con <strong>k</strong> come limite si può dividere in queste parti:
</p><ol><li>vado da <strong>i</strong> a <strong>k</strong>, e posso anche abbassare il limite a <strong>k - 1</strong> (infatti il limite vale sugli stati intermedi e non su quelli finali o iniziali)
</li><li>poi ho tutte le parti in mezzo che vanno da <strong>k</strong> a <strong>k</strong>, in cui anche qui posso abbassare il limite a <strong>k -1</strong> per analoghe considerazione
</li><li>poi ho i cammini che vanno da <strong>k</strong> a <strong>j</strong>, ed anche qui posso abbassare il limite a <strong>k -1</strong>
</li><li>infine, c'è anche l'eventualità che non si attraversino stati <strong>k</strong>
</li></ol><p class='vspace'>Tutti questi 4 punti possono essere tradotti in regexp, ed il risultato è questo:
</p><pre> <strong>R<sup>(k)</sup><sub>i,j</sub> = R<sup>(k-1)</sup><sub>i,k</sub> (R<sup>(k-1)</sup><sub>k,k</sub>)<sup>*</sup> R<sup>(k-1)</sup><sub>k,j</sub> + R<sup>(k-1)</sup><sub>i,j</sub></strong>
</pre><p class='vspace'>Come avrete notato, i primi tre punti li ho <strong>concatenati</strong>, mentre l'ultimo punto l'ho messo come <strong>alternativa</strong>.<br />Il fatto che ad ogni passo ottengo <strong>k-1</strong> mi permette di dire che, se anche partissi da <strong>R<sup>(n)</sup><sub>i,j</sub></strong>, alla fine arriverò sempre ad un caso base (ad ogni passo tolgo 1 etc. etc finché non arrivo a 0), e pertanto la costruzione della mia regexp sarà induttivamente corretta.
</p>
<div class='vspace'></div><h3>Un metodo un po' più furbo</h3>
<p>Il sistema che abbiamo visto sopra, che potete realizzare seguendo anche solo la descrizione intuitiva dello stesso, non è furbissimo, perché ci saranno un sacco di stati intermedi in cui tutti i cammini passeranno, e siccome la mia costruzione della regexp prevede di concatenare il tutto, mi ritroverò a concatenare mille volte lo stesso stato. L'equivalenza è garantita, ma l'efficienza no.
</p>
<p class='vspace'>Però possiamo adottare questo stratagemma, esemplificato in questo diagramma:
</p>
<div class='vspace'></div><div><span class='frame lfloat'><img src='../uploads/Uni/trad-a-re-2.png' alt='' title='' /></span></div>
<p class='vspace'>Vista la magia? Etichetto l'arco con una regexp direttamente! Il sistema in uso è sempre quello di sopra: più archi uscenti diventano un'alternativa, i loop diventano * e i cammini si concatenano. Ma in questo modo riesco ad evitare di costruire stati inutili. Passo passo, parto da un FA ed arrivo alla mia regexp ben pulito, avendo ottenuto una singola regexp per ogni cammino che porta dallo stato iniziale ad uno finale.
</p>
<div class='vspace'></div><h3>Da Regexp a FA</h3>
<p>Ora vogliamo fare il passo inverso, ovvero prendere una regexp e ricavarne l'automa. D'altro canto, quando ad esempio in un programma di videoscrittura facciamo una ricerca tramite regexp, il software esegue proprio questa conversione e dà in pasto all'automa così generato i caratteri del testo. Il procedimento di dimostrazione sarà sempre la solita beneamata induzione.
</p>
<p class='vspace'><strong>Caso base:</strong> <strong>&#8709;, &#949;</strong> e <strong>a</strong> intese come regexp singole.<br />Non c'è molto da dire:
</p><ul><li>la &#949; diventa una &#949;-mossa
</li><li>il &#8709; non diventa nessun arco, proprio perché è l'insieme vuoto
</li><li>la <strong>a</strong> diventa un arco etichettato con <strong>a</strong>
</li></ul><p class='vspace'><strong>Passo induttivo:</strong> R + S, RS, R<sup>*</sup><br />R e S sono le mie due regexp. Abbiamo definito la trasformazione delle regexp base nel caso base, e ora procediamo induttivamente con i casi più impestati.
</p>
<p class='vspace'><strong>R + S</strong> si traduce così:
</p><div><img src='../uploads/Uni/trad-RpiuS.png' alt='' title='' /></div>
<p class='vspace'><strong>RS</strong> si traduce così:
</p><div><img src='../uploads/Uni/trad-RS.png' alt='' title='' /></div>
<p class='vspace'><strong>R<sup>*</sup></strong> si traduce così:
</p><div><img src='../uploads/Uni/trad-Rstar.png' alt='' title='' /></div>
<p class='vspace'>Questi sono i mattoncini che vengono utilizzati per scomporre passo passo una regexp, e costruire un FA equivalente. Poi, se vogliamo in modo particolare un DFA, allora provvediamo a de-indeterminizzare questo automa, a levare le &#949;-mosse e così via. Ma tanto sappiamo che sono tutti equivalenti. Bisogna solo stare attenti a concatenare le cose per bene: nelle figure qui sopra, i rettangoli rappresentano delle regexp già fatte. Poi, ricorsivamente, andrò a scomporre anche loro etc. etc. fino a che non ottengo un bell'automa.
</p>
<div class='vspace'></div><h2>Equivalenza tra grammatiche regolari ed automi</h2>
<p>Il nostro giro nel mondo delle equivalenze non è ancora finito. Ora vogliamo vedere in che modo è possibile dimostrare l'equivalenza tra grammatiche regolari ed automi.
</p>
<p class='vspace'>In particolare, voglio passare da <strong>A = (Q, &#931;, &#948;, q<sub>0</sub>, F)</strong> a una <strong>G = (NT, T, S, P)</strong>.<br />Definisco la <strong>G</strong> in questo modo:
</p><ul><li><strong>NT = Q</strong>, cioè l'insieme dei simboli non terminali viene costruito con l'insieme degli stati dell'automa;
</li><li><strong>T = &#931;</strong>, il che vuol dire che i simboli terminali sono l'alfabeto dell'automa;
</li><li><strong>S = q<sub>0</sub></strong>, cioè l'assioma della grammatica è, prevedibilmente, il mio stato iniziale.
</li></ul><p class='vspace'>Il passo successivo consiste nel convertire la &#948; in regole di produzione.<br />In generale si avrà <strong>&#948; = (q<sub>i</sub>, ak) = q<sub>j</sub></strong>, cioè passo da un certo stato con un certo input in un altro stato.
</p><ul><li>se q<sub>j</sub> <strong>non</strong> appartiene agli stati finali, allora <strong>q<sub>i</sub>::= akq<sub>j</sub></strong> 
</li><li>se q<sub>j</sub> <strong>appartiene</strong> agli stati finali, allora <strong>q<sub>i</sub>::= ak</strong> 
</li></ul><p class='vspace'>L'idea è piuttosto intuitiva: se dal mio stato parte un arco che porta in un altro stato non finale, allora devo mettere nella regola il nome di quello stato, che abbiamo visto essere diventato un NT. Se invece quell'input mi porta in uno stato finale, metto nella regola direttamente il simbolo dell'alfbeto che lì mi conduce.
</p>
<p class='vspace'>Vediamo un esempio:
</p><div><img src='../uploads/Uni/trad-a-g.png' alt='' title='' /></div>
<p class='vspace'>Ed ecco le regole con relativa spiegazione.
</p>
<p class='vspace'><strong>q<sub>0</sub>::= a | aq<sub>0</sub> | bq<sub>1</sub> </strong><br />Dallo stato <strong>q<sub>0</sub></strong> infatti posso andare in uno stato finale (<strong>q<sub>0</sub></strong> stesso) con <strong>a</strong>, che quindi è un simbolo terminale. Ma è un loop, e quindi devo anche prevedere di poter tornare su me stesso, ed ecco perché metto anche <strong>aq<sub>0</sub></strong>. Infine, posso andare in <strong>q<sub>q</sub></strong> con <strong>b</strong>.
</p>
<p class='vspace'><strong>q<sub>1</sub>::= bq<sub>2</sub> | b</strong><br />Da <strong>q<sub>1</sub></strong> mi sposto solo con <strong>b</strong>. Se arrivo in <strong>q<sub>2</sub></strong>, potrei aver terminato, ma siccome anche <strong>q<sub>2</sub></strong> ha delle frecce che escono, allora devo considerare anche l'eventualità di non fermarmi in <strong>q<sub>2</sub></strong>.
</p>
<p class='vspace'><strong>q<sub>2</sub>::= bq<sub>3</sub> | a | aq<sub>2</sub></strong><br />Il ragionamento è analogo: con la <strong>b</strong> vado in <strong>q<sub>3</sub></strong>, che non è finale, e quindi è un NT. Con la <strong>a</strong> rimango in <strong>q<sub>2</sub></strong>, ma posso rimanerci sia per concludere che per proseguire, ed ecco perché ho sia <strong>a</strong> che <strong>aq<sub>2</sub></strong>.
</p>
<p class='vspace'><strong>q<sub>3</sub>::= bq<sub>0</sub> | b</strong><br />Abbiamo capito il giochetto, e qui non facciamo eccezione.
</p>
<p class='vspace'>Attenzione ad una cosa importante: in generale gli automi accettano senza problemi anche le &#949;, mentre le grammatiche NO! O meglio, le grammatiche 0 e 1 sì, mentre quelle regolari no.
</p>
<div class='vspace'></div><h3>Da grammatica regolare ad automa</h3>
<p>L'ultimo passo di conversione è quello che ci porta da una grammatica regolare <strong>G</strong> ad un <strong>FA</strong>. Ci sono delle semplici condizioni di conversione:
</p><ul><li>l'assioma della <strong>G</strong> diventa il mio <strong>stato iniziale</strong>;
</li><li>i simboli <strong>T</strong> diventano <strong>stati finali</strong>;
</li><li>tutte le <strong>produzioni</strong> vanno convertite in <strong>archi</strong>.
</li></ul><p class='vspace'>Non è sempre banale, tuttavia, convertire le grammatiche regolari in automa. Abbiamo visto che ci sono grammatiche regolari destre e sinistre, e noi vedremo - per ora - solo la conversione da grammatiche regolari destre. Le regole di conversione sono le seguenti:
</p><ul><li><strong>X::=aA</strong> diventa <strong>X -&gt;<sup>a</sup> A</strong>
</li><li><strong>X::=a</strong> diventa <strong>X -&gt;<sup>a</sup> Z</strong>
</li><li><strong>X::=&#949;</strong> diventa <strong>X -&gt;<sup>&#949;</sup> Z</strong>
</li></ul><p>La scrittura <strong>X -&gt;<sup>a</sup> A</strong> mi dice che vado dallo stato <strong>X</strong> allo stato <strong>A</strong> tramite un arco etichettato con <strong>a</strong>.
</p>
<p class='vspace'>Non s'era detto che le grammatiche non amano le produzioni con la &#949;? È vero. E allora questa che cosa ci fa qui? BOH!
</p>
<div class='vspace'></div><hr />
<p><a class='wikilink' href='Traduttori.html'>Torna alla pagina di Traduttori</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/Trad260309)</span></div>
  </div>
</body>
</html>
