<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Traduttori - Appunti del 19 marzo 2009</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='Trad190309.html' title='Traduttori - Appunti del 19 marzo 2009'>Traduttori - Appunti del 19 marzo 2009</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
</p><pre> <a class='wikilink' href='Traduttori.html'>Torna alla pagina di Traduttori</a>
</pre><p class='vspace'  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'><strong>:: Traduttori - Appunti del 19 marzo 2009 ::</strong>
</p>
<div class='vspace'></div><h2>Automi</h2>
<p>Discorsi introduttivi sugli automi sono stati fatti in mille materie diverse. Quello che interessa a noi è sapere a che cosa servono nell'ambito dei Traduttori.
</p>
<p class='vspace'>Possiamo rappresentarli in diversi modi. Uno di questi consiste nell'immaginare un automa come una specie di macchina con una testina, la quale testina è posizionata su di un nastro. Questo nastro è composto da celle, ed ogni casella rappresenta un simbolo in input. La macchina legge il simbolo contenuto nella cella, cambia il proprio stato interno, ed avanza il nastro di una posizione.
</p>
<div class='vspace'></div><div><span class='frame lfloat'><img src='../uploads/Uni/TradAutoma01.png' alt='' title='' /><br /><strong>Un'automa</strong></span></div>
<p class='vspace'>Assomigliano un po' alle Macchine di Turing. Un altro modo per rappresentare un automa è quello dei <strong>pallogrammi</strong>, che si usano un po' dappertutto.
</p>
<p class='vspace'><br clear='all' />
</p><h3>Definizione formale</h3>
<p>Un automa <strong>A</strong> consiste in una quintupla:
</p><pre> <strong>A = (Q, &#931;, &#948;, q<sub>0</sub>, F)</strong>
</pre><p>ed ecco la spiegazione:
</p><ul><li><strong>Q</strong> = insieme finito di stati
</li><li><strong>&#931;</strong> = alfabeto
</li><li><strong>q</strong><sub>0</sub> = stato iniziale
</li><li><strong>&#948;</strong> = funzione di transizione: <strong>Q x &#948; -&gt; Q</strong>
</li><li><strong>F</strong> = sottinsieme degli stati di Q, detti <strong>stati finali</strong> o di <strong>accettazione</strong>
</li></ul><p class='vspace'>La macchina parte nello sato <strong>q<sub>0</sub></strong>, e gli do in pasto il primo elemento della stringa di input. Le <strong>transizioni</strong> portano la macchina in uno stato o in un altro a seconda dell'input in arrivo e dello stato attuale.<br />Questa stringa di input viene <strong>accettata</strong> se, dopo aver percorso tutta la stringa di input, l'automa si trova in uno degli stati <strong>F</strong>, cioè stati di accettazione. Vediamo quindi che finalmente si attua l'idea, più volte menzionata nel corso delle precedenti lezioni, di <strong>riconoscitore</strong> di linguaggi.
</p>
<div class='vspace'></div><h3>Estensione della funzione di transizione</h3>
<p>La funzione di transizione <strong>&#948;</strong> viene però in genere estesa, per facilitare (?) le cose. Si definisce quindi un'altra funzione:
</p><pre> <strong>&#948;^ = Q * &#931;<sup>*</sup> -&gt; Q</strong>
</pre><p>Attenzione: in <strong>&#948;^</strong> l'accento circonflesso è detto <strong>cap</strong> e dovrebbe stare sopra il &#948;, ma non ho trovato un modo per mettercelo... La funzione si chiama quindi <strong>delta cap</strong>.
</p>
<p class='vspace'>La &#948;^ ci permette quindi di associare funzioni di transizione non solo ai singoli simboli, ma anche alle stringhe: posso quindi riconoscere interi linguaggi.
</p>
<div class='vspace'></div><h3>Linguaggi definiti dagli automi</h3>
<p>Un linguaggio definito da un automa lo segno così:
</p><pre> <strong>L(A) =  {w | &#948;^ (q<sub>0</sub>, w) &#8712; a F}</strong>
</pre><p>e questa è la spiegazione: il linguaggio definito dall'automa <strong>A</strong> è quel linguaggio composto da tutte le stringhe <strong>w</strong> che vengono accettate dall'automa stesso. L'accettazione viene rappresentata dicendo che la funzione <strong>&#948;^</strong>, applicata alla stringa <strong>w</strong>, partendo dallo stato iniziale <strong>q<sub>0</sub></strong>, deve portare l'automa in uno stato finale appartenente agli stati di <strong>accettazione</strong>.
</p>
<div class='vspace'></div><h3>Definizione induttiva di &#948;^</h3>
<p><strong>Base induttiva</strong>:
</p><pre> &#948;^(q, &#949;) = q
</pre><p>Vuol dire che, se sono in uno stato, e leggo la stringa vuota, non mi muovo da quello stato.
</p>
<p class='vspace'><strong>Passo induttivo</strong>:
</p><pre> w = xa, dove x &#8712; &#931;<sup>*</sup> e a &#8712; <sup>&#931;</sup>
 &#948;^(q, xa) = &#948;(&#948;^(q, x), a)
</pre><p>Questo vuol dire che, data una stringa <strong>w</strong> composta da una stringa <strong>x</strong> e da un simbolo <strong>a</strong>, il risultato della funzione <strong>&#948;^</strong> applicata ad essa consiste nell'applicare ricorsivamente la <strong>&#948;^</strong> alla stringa <strong>x</strong>, e poi applicare la <strong>&#948;</strong> al simbolo <strong>a</strong>. Ricorrendo ricorrendo si arriva infine ad avere la <strong>&#948;^</strong> come una sorta di "semplificazione" dell'applicazione ripetuta di <strong>&#948;</strong> ai singolo elementi di una stringa.
</p>
<div class='vspace'></div><h3>Automi non deterministici</h3>
<p>Gli automi visti finora sono di tipo <strong>deterministico</strong>. In questo contesto, deterministico vuol dire che, a partire da un certo stato, applicando un certo input la <strong>&#948;^</strong> mi conduce in un solo stato.
</p>
<p class='vspace'>L'automa <strong>non deterministico</strong> invece ha una <strong>&#948;^</strong> particolare, tale che a partire da uno stato, applicando un certo input, può portarmi in uno o più stati <strong>contemporaneamente</strong>. È come se, in presenza di quel particolare input arrivato in un certo stato, la macchina si sdoppiasse (o triplicasse etc.) in due diversi thread paralleli, ognuno dei quali va avanti per la sua strada.
</p>
<p class='vspace'>La mia <strong>&#948;^</strong> viene quindi ridefinita:
</p><pre> &#948;^: Q x &#931;<sup>*</sup> -&gt; &#8473;(Q)
</pre><p>dove <strong>&#8473;(Q)</strong> rappresenta qualcosa come un <strong>insieme di stati</strong>.
</p>
<p class='vspace'  style='text-align: center; background-color: red; border: 3px dotted yellow; padding: 3px;'><span  style='color: white;'><strong>Warning: definizione da migliorare...</strong></span>
</p>
<div class='vspace'></div><h3>Definizione induttiva di &#948;^ per automi non deterministici</h3>
<p><strong>Base induttiva:</strong>
</p><pre> |w| = 0 =&gt; w = &#949;
 &#948;^(q, &#949;) = {q}
</pre><p>Vuol dire che se la cardinalità di una certa stringa è 0, allora quella stringa è <strong>vuota</strong>. La <strong>&#948;^</strong> applicata ad una <strong>&#949;</strong> mi fa rimanere nello stesso stato in cui mi trovavo.<br />Il fatto che io segni lo stato di destinazione con <strong>{q}</strong> sta a significare che, come abbiamo visto qui sopra, la <strong>&#948;^</strong> mi porta in un <strong>insieme</strong> di stati, e non in uno stato solo. In questo caso l'insieme di stati è popolato da un solo elemento, ma in generale un automa non deterministico può portarmi in un numero qualunque di stati.
</p>
<p class='vspace'><strong>Passo induttivo:</strong>
</p><pre> w = xa, x &#8712; &#931;<sup>*</sup>, a &#8712; &#931;
 &#948;^(q, xa) = Unione, &#8704; p &#8712; &#948;^(q,x), &#948;(p,a)
</pre><p>Questo vuol dire che applico la <strong>&#948;</strong> ad ogni sottostringa di <strong>xa</strong>, e ottengo un <strong>insieme</strong> di stati, che uniti compongono il risultato della <strong>&#948;^</strong>
</p>
<p class='vspace'>Riassumendo, la mia <strong>&#948;^</strong> è una funzione che, dato uno stato e una stringa in input, mi porta in un insieme di stati contemporaneamente, e in linea teorica il mio automa non deterministico avvierà un'esplorazione parallela ed indipendente di ogni stato in cui la <strong>&#948;^</strong> mi ha portato.
</p>
<div class='vspace'></div><h3>Linguaggi definiti dagli automi non deterministici</h3>
<p>I linguaggi che vengono definiti, cioè riconosciuti, dagli automi non deterministici si rappresentano così:
</p><pre> L(N) = { w | &#948;^(q<sub>0</sub>, w) &#8838; F}
</pre><p>Il significato è che una stringa <strong>w</strong> appartiene al linguaggio definito dal mio automa <strong>N</strong> se, applicando la <strong>&#948;^</strong> a partire dallo stato <strong>q<sub>0</sub></strong>, almeno uno degli stati finali in cui mi trovo sarà uno <strong>stato di accettazione</strong>. Non tutti: almeno uno.
</p>
<div class='vspace'></div><h3>Equivalenza tra automi deterministici e automi non deterministici</h3>
<p>I DFA e gli NFA (rispettivamente, automi deterministici e automi non deterministici) sono equivalenti: è sempre possibile rappresentare un automa in una delle due forme.
</p>
<p class='vspace'>Il <strong>teorema di Rabin Scott</strong> dimostra proprio questo: se a partire da un NFA costruisco un DFA in un certo modo, ho la certezza che essi saranno equivalenti, ovvero riconosceranno come appartenenti al linguaggio le stesse stringhe, e nessun'altra.
</p>
<div class='vspace'></div><h3>Dimostrazione del teorema di Rabin Scott</h3>
<p>Il teorema prevede di costruire in un certo modo, a partire da un NFA, un certo DFA, e poi dimostrarne l'equivalenza proprio in virtù di questa costruzione, detta <strong>costruzione per sottinsiemi</strong>.
</p>
<p class='vspace'>In particolare, vogliamo che <strong>gli stati del DFA</strong> siano pari a <strong>tutti i sottinsiemi</strong> degli stati del NFA. La cardinalità dell'insieme dei sottinsiemi di un insieme (puff!) è <strong>2<sup>n</sup></strong>, e pertano mi aspetto di trovare 2<sup>n</sup> stati nel mio DFA così costruito. Informo però da subito che nella maggior parte dei casi saranno necessari molti meno stati.<br />Riassumendo, sto dicendo che il singolo stato del DFA è un insieme di stati dell'NFA.
</p>
<p class='vspace'>A che cosa serve l'insieme dei sottinsiemi? Server per creare la mia funzione <strong>&#948;<sub>D</sub></strong> a partire dalla <strong>&#948;<sub>N</sub></strong>. Ecco come:
</p><pre> &#948;<sub>D</sub>(S, a) = U, &#8704; p &#8712; S, &#948;<sub>N</sub>(p, a)
</pre><p class='vspace'>Il significato è il seguente: la funzione &#948; dell'automa deterministico porta, come al solito, da uno stato ad un altro stato a seconda dell'input <strong>a</strong> che le viene dato. Sappiamo altresì che la &#948; di un automa non deterministico invece porta ad un <strong>insieme di stati</strong>.<br />Orbene, la &#948; definita qui sopra dice che l'input <strong>a</strong> mi porta in uno stato, che è composto dall<strong>'unione</strong> di tutti gli stati raggiungibili con la &#948; non deterministica!
</p>
<p class='vspace'>Ecco a che cosa serve dire che l'insieme degli stati del DFA è l'insieme dei sottinsiemi. L'NFA porterà ad un certo numero di stati, i quali saranno <strong>sottinsiemi</strong> dell'insieme totale degli stati dell'NFA. Pertanto, se lo stato del DFA rappresenta un <strong>sottinsieme</strong> degli stati del NFA, allora vuol dire che portano allo stesso punto.
</p>
<p class='vspace'>La dimostrazione dell'equivalenza tra NFA e DFA così costruito avviene per induzione. Definiamo la nostra <strong>&#948;^</strong>:
</p><pre> &#948;^<sub>D</sub>({q<sub>0</sub>}, w) = &#948;^<sub>N</sub>(q<sub>0</sub>,w)
</pre><p>Come vedete, la &#948;^<sub>D</sub> agisce su {q<sub>0</sub>}, e questa è la scrittura che mi dice che ho a che fare con un <strong>insieme</strong>. Infatti, come dicevo sopra e come ripeto ancora, i singoli stati del DFA sono tutti sottinsiemi degli stati del NFA.
</p>
<p class='vspace'><strong>Caso base:</strong> w = &#949;<br />Per definizione di &#948;^, sappiamo che con la stringa vuota non si va da nessuna parte, e pertanto:
</p><pre> &#948;^<sub>D</sub>({q<sub>0</sub>}, &#949;) = &#948;^<sub>N</sub>(q<sub>0</sub>, &#949;) = {q<sub>0</sub>}
</pre><p>Le graffe sono qui per ricordarci che abbiamo a che fare con insiemi di insiemi.
</p>
<p class='vspace'><strong>Induzione</strong>: w = xa, in cui <strong>x</strong> è una stringa e <strong>a</strong> un singolo carattere.<br />Per ipotesi induttiva sappiamo che il caso base è valido per la stringa x:
</p><pre> &#948;^<sub>D</sub>({q<sub>0</sub>}, x) = &#948;^<sub>N</sub>(q<sub>0</sub>, x)
</pre><p class='vspace'>Conosciamo inoltre la definizione di &#948;^:
</p><pre> &#948;^<sub>D</sub>({q<sub>0</sub>}, xa) = &#948;<sub>D</sub>(&#948;^<sub>D</sub>({q<sub>0</sub>},x), a)
</pre><p>Ricordate? La &#948;^ è definita come l'applicazione ricorsiva della &#948; ad ogni componente della stringa. Andate a vedere i vecchi appunti se non mi credete:)
</p>
<p class='vspace'>Ma l'ipotesi induttiva vista sopra ci dice che &#948;^<sub>D</sub> = &#948;^<sub>N</sub>. Pertanto, possiamo riscrivere la formuletta del paragrafo precedente così:
</p><pre> &#948;^<sub>D</sub>({q<sub>0</sub>}, xa) = &#948;<sub>D</sub>(&#948;^<sub>N</sub>(q<sub>0</sub>,x), a)
</pre><p class='vspace'>Inoltre, sappiamo come abbiamo costruito la nostra &#948;^<sub>D</sub>:
</p><pre> &#948;<sub>D</sub>(S, a) = U, &#8704; p &#8712; S, &#948;<sub>N</sub>(p, a)
</pre><p class='vspace'>Riscrivendola con q<sub>0</sub> al posto di S avremo:
</p><pre> &#948;^<sub>D</sub>({q<sub>0</sub>}, xa) = U, p &#8712; &#948;^<sub>N</sub>(q<sub>0</sub>, x), &#948;<sub>N</sub>(p, a)
</pre><p class='vspace'>e se siete stati attenti avrete visto che la parte a destra dell'uguale è la <strong>definizione</strong> di &#948;^<sub>N</sub>! Ecco quindi che, avendo costruito l'automa D in quel modo, possiamo infine dire:
</p><pre> &#948;^<sub>D</sub> = &#948;^<sub>N</sub>
</pre><div class='vspace'></div><hr />
<p><a class='wikilink' href='Traduttori.html'>Torna alla pagina di Traduttori</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/Trad190309)</span></div>
  </div>
</body>
</html>
