<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Sistemi Operativi - Lezione del 31 marzo 2008 </title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='Piuri31Marzo2008.html' title='Sistemi Operativi - Lezione del 31 marzo 2008 '>Sistemi Operativi - Lezione del 31 marzo 2008 </a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
</p><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: Sistemi operativi - Lezione del 31 marzo 2008 ::</strong>
</pre><p class='vspace'><a class='wikilink' href='SistemiOperativi.html'>Torna alla pagina di Sistemi Operativi</a>
</p>
<p class='vspace'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 1: Caratterizzazione dei deadlock</strong></span>
</p>
<p class='vspace'>I deadlock (dl da qui in poi) non accadono sempre: devono essere soddisfatte 4 condizioni affinché accadano.
</p>
<div class='vspace'></div><ol><li>C'è una risorsa in mutua esclusione.
</li><li>Hold &amp; wait
</li><li>Assenza di rilascio anticipato
</li><li>Attesa circolare
</li></ol><p class='vspace'><strong>Mutua esclusione</strong>: ovviamente, se non ho risorse per cui "lottare", non c'è nemmeno una possibilità di dl.
</p>
<p class='vspace'><strong>Hold &amp; Wait</strong>: è una situazione in cui un processo ha già delle risorse (<strong>hold</strong>), ma deve attenderne ancora delle altre (<strong>wait</strong>).
</p>
<p class='vspace'><strong>Assenza di rilascio anticipato</strong>: vuol dire che non posso privare un processo delle risorse che ha già acquisito.
</p>
<p class='vspace'><strong>Attesa circolare</strong>: Il processo A ha delle risorse e ne attende dal processo B, il quale a sua volta attende le risorse di A. Insomma, un cerchio dell'ammmore, con anche più di 2 processi.
</p>
<p class='vspace'>Quando <strong>tutte</strong> ste condizioni sono verificate, ho un dl.
</p>
<div class='vspace'></div><h3>I grafi di allocazione delle risorse</h3>
<p>Suddetti grafi hanno come nodi le risorse ed i processi.
</p>
<p class='vspace'>Un arco uscente da una risorsa ed entrante in un nodo significa che quella risorsa è assegnata a quel nodo.
Un arco uscente da un nodo ed entrante in una risorsa significa che quel nodo ha fatto richiesta di quella risorsa.
</p>
<p class='vspace'>Inoltre, le risorse hanno dei pallini. X pallini nel nodo della risorsa stanno a significare che ci sono X copie di quella risorsa disponibili da dar via.
</p>
<p class='vspace'>Ho un dl quando ho un ciclo, e devo verificare anche che i pallini siano tutti esauriti. Ma non è sempre vero che se ho un ciclo ho un dl: infatti, se i pallini <strong>non</strong> sono esauriti, allora non ho un deadlock. Quindi occhio ai pallini! Non fatemelo disegnare, please...
</p>
<p class='vspace'>Attenzione: in un sistema distribuito, il grafo si fa molto più complesso. Noi qui ci occupiamo solo dei sistemi monocalcolatore.
</p>
<div class='vspace'></div><h3>Gestire il deadlock</h3>
<p>Un SO può porsi in modi diversi di fronte al problema del deadlock. Mantenere un grafo delle risorse e periodicamente controllarlo può essere una via.
</p>
<p class='vspace'>Ci sono però diverse strategie a disposizione:
</p><ul><li>Ignorare bellamente il deadlock
</li><li>Prevenire il deadlock
</li><li>Evitare il deadlock
</li><li>Rilevarlo e recuperare
</li></ul><p class='vspace'><strong>Ignorare</strong> il dl vuol dire esattamente quello: ignorare. Perché mai? La risposta è che la frequenza con cui i deadlock si presentano è molto bassa; l'utente in genere dopo un po' se ne accorge, e ci penserà lui ad accoppare i processi. È parimenti molto bassa la probabilità che al prossimo riavvio i processi si metteranno in un ordine tale per cui il dl accada di nuovo.
</p>
<p class='vspace'><strong>Prevenire</strong> il dl vuol dire invece fare in modo che un processo venga attivato SOLO se c'è certezza che il dl non avvenga mai.
</p>
<p class='vspace'><strong>Evitare</strong> invece permette che i processi partano, e poi vede di smanettare per evitare che i processi già partiti creino dl. Quindi, a differenza della <strong>prevenzione</strong>, non impedisce ai processi di essere esguiti.
</p>
<p class='vspace'><strong>Rilevazione e recupero</strong> sta a significare che il SO permette che il deadlock accada, e poi vedrà in qualche modo di accorgersene, e uccidere processi finché il dl non scompare.
</p>
<p class='vspace'>Ognuna di queste scelte ha il suo costo, tenendo in mente sia quanto tempo perdo a rilevare i dl, sia quanto è alta la probabilità che accadano. Quindi occorre bilanciare.
</p>
<p class='vspace'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 2: Tecniche di prevenzione del deadlock</strong></span>
</p>
<div class='vspace'></div><div><span class='frame lfloat'><img src='../uploads/Uni/dreadlock.jpg' alt='' title='' /><br /><strong>Un d(r)eadlock</strong></span></div>
<p>Si tratta di tecniche che cercano di annullare una della 4 condizioni viste prima, dal momento che abbiamo detto che devono verificarsi tutte e 4 per avere un deadlock.
</p>
<div class='vspace'></div><h3>Prevenire la mutua esclusione</h3>
<p>Il SO cerca di fare in modo che solo le risorse che ne hanno bisogno possano attivare la mutex, ovvero quello che ne hanno <strong>intrinsecamente</strong> bisogno.
Per le altre, impedisce la mutex: se il loro utilizzo condiviso non crea problemi, perché inventarsene?
</p>
<div class='vspace'></div><h3>Prevenire la hold &amp; wait</h3>
<p>È la condizione per cui un processo che ha delle risorse sta attendendo che se ne liberino delle altre. Per evitare una situazione del genere, ci sono 2 approcci:
</p>
<p class='vspace'><strong>1.</strong> Un processo deve chiedere in blocco tutte le risorse necessarie quando viene avviato. Se non le ha tutte, non viene nemmeno avviato. Alla fine, le rilascia tutte.
</p>
<p class='vspace'>Il problema qui è evidente: il programma va scritto nel modo opportuno, innanzitutto. Ma poi, succede anche che si riduce di parecchio il parallelismo, perché un processo può monopolizzare anche delle risorse che usa poco, e impedire che altri ne usufruiscano e avanzino nella loro computazione.
</p>
<p class='vspace'><strong>2.</strong> Un processo che vuole delle risorse ulteriori rispetto a quelle che ha già, deve rilasciarle tutte e poi, all'occorrenza, riprenderle ancora tutte PIÙ quella che gli serve in quel momento. 
</p>
<p class='vspace'>Almeno questo sistema garantisce un po' di parallelismo in più rispetto al sistema <strong>1</strong>.
</p>
<p class='vspace'>Comunque, quale che sia il mio metodo per prevenire la hold &amp; wait, ho che in generale le risorse vengono sottoutilizzate per via di queste "paranoie" sul lock, e alcuni processi potrebbero morire di starvation, ovvero attendere indefinitamente che i progressi prepotenti liberino le risorse.
</p>
<div class='vspace'></div><h3>Preemption</h3>
<p>Vuol dire, in altre parole, prevenire la non-preemption:)
Preemption vuol dire che rubo le risorse ad un processo per darle ad un altro. Naturalmente il furto non è sempre giustificato, occorre rispettare delle condizioni, ovvero che il rilascio anticipato NON crei problemi di consistenza.
</p>
<p class='vspace'>Se un processo chiede risorse, e ne ha delle altre che non sono rilasciabili, allora
</p><ul><li>rilascio anticipatamente tutte le sue risorse;
</li><li>metto le mie vecchie risorse nella lista di quelle che vorrei;
</li><li>aspetto di riaverle tutte.
</li></ul><p class='vspace'>È come il sistema 2 della prevenzione della hold &amp; wait, con la differenza che qui rilascio solo le risorse che possono essere ripristinate, ovvero che non creerebbero problemi di consistenza.
</p>
<p class='vspace'>Se un processo chiede risorse
</p><ul><li>se sono disponibili, pronti, gliele diamo.
</li><li>se NON sono disponibili, devo agire in 2 modi diversi
<ul><li>se appartengono ad un processo che deve attendere altre risorse, allora gliele posso fregare: aspetterà un po' di più.
</li><li>se appartengono a processi che invece le stanno usando, allora sarò io ad attendere.
</li></ul></li></ul><p class='vspace'>Ciò vuol dire che faccio preemption solo se c'è un processo in attesa di <em>altre</em> risorse, altrimenti no.
</p>
<div class='vspace'></div><h3>Prevenzione dell'attesa circolare</h3>
<p>Questa mi sa che è la più paranoica.
Devo dare un ordinamento globale a TUTTE le mie risorse, in modo che siano numerate, e che date due risorse io sappia sempre dire se l'indice di una è maggiore o minore dell'indice dell'altra.
</p>
<p class='vspace'>Fatto ciò (che è una cosa ingrata), obbligo i processi a chiedere SOLO risorse che indice MAGGIORE di quello della risorsa con più grande indice che già ha.
In altre parole, se il processo A ha la risorsa R<sub>25</sub>, potrà chiedere solo risorse indicizzate da R<sub>26</sub> in su, e non da R<sub>25</sub> in giù.
</p>
<p class='vspace'>Se proprio vuole risorse con indice più basso, allora deve mollare tutte quelle che ha con indice maggiore di quella voluta, e ripartire da quella con indice più basso.
</p>
<p class='vspace'>Sembrerà balordo, ma evita le attese circolari, perché non potrà mai accadere che due processi si attendano l'un l'altro: gli indici lo proibiscono.
</p>
<p class='vspace'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>Lezione 4 - Tecniche per rilevazione e ripristino</strong></span>
</p>
<p class='vspace'>Permetto che accada il dl, lo rilevo e poi recupero.
</p>
<p class='vspace'>Vi ricordate il grafo delle allocazioni di prima?
Bene. Facciamo ora la considerazione che, sinceramente, di sapere QUALE sia la risorsa che causa il dilemma, a noi non interessa niente. Ci basta sapere che un processo attende da un'altro processo, e tant'è.
</p>
<p class='vspace'>In questo modo, possiamo togliere un sacco di nodi dal grafo, renderlo più semplice e quindi avere un algoritmo di rilevamento dei cicli che lavora su un numero inferiore di nodi, ovvero tendenzialmente più rapido. Questo grafo si chiama <strong>wait-for</strong>, in cui un arco uscente da un nodo-processo ed entrante in un altro nodo-processo sta a significare che il primo processo vuole qualcosa che il secondo ha.
</p>
<p class='vspace'>Purtroppo, questo funziona SOLO se ho risorse con istanze singole. Se ho risorse con istanze multiple (il numero di pallini del grafo di allocazione delle risorse, per intenderci), allora la cosa si fa molto più complicata.
Non basta più un grafo, occorrono delle matrici e dei vettori, e l'algoritmo si fa molto più complesso.
</p>
<div class='vspace'></div><h3>Quando faccio partire quest'algoritmo?</h3>
<p>Posso decidere di farlo partire ogni volta che un processo chiede una risorsa e scopre che è occupata. Ok, però si capisce subito che l'overhead diventa tanto: chissà quante volte devo controllare il grafo!
</p>
<p class='vspace'>Altrimenti, decido di eseguire l'algoritmo ogni tot tempo. Il problema è che magari nel frattempo si possono essere accumulati un po' di stalli. Ma è sicuramente meno costoso che farlo ad ogni richiesta fallita.
</p>
<div class='vspace'></div><h3>E quando ho trovato un dl?</h3>
<p>Un sistema un po' barbaro ma efficace consiste nell'accoppare tutti i processi che stanno nel ciclo. Sicuramente risolvo il problema del dl, ma è altrettanto sicuro che spreco un sacco di risorse uccidendo processi magari innocenti.
</p>
<p class='vspace'>Oppure, ne posso uccidere uno alla volta (di processi), fintantoché il dl non scompare. Lo svantaggio è che devo ripetere l'algo per ogni uccisione.
</p>
<div class='vspace'></div><h3>Ok, uccido processi. Ma quali?</h3>
<p>Posso scegliere un criterio qualsiasi per uccidere i processi, nel caso non voglia compiere un genocidio. Posso ad esempio prendere quelli con priorità più bassa, o quelli che sono in esecuzione da meno tempo o quelli fatti partire da un utente a me antipatico.
</p>
<p class='vspace'>Qualsiasi cosa io faccia, devo però stare attento a far sì che le risorse che vengono rilasciate forzatamente possano fare un rollback e tornare in uno stato consistente precedente. E poi, devo anche stare attento quando uso un criterio, perché può darsi che ad ogni deadlock che si ripresenta, uccido sempre il solito processo sfortunato, il quale quindi andrebbe a trovarsi in una situazione di starvation.
</p>
<p class='vspace'><a class='wikilink' href='SistemiOperativi.html'>Torna alla pagina di Sistemi Operativi</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/Piuri31Marzo2008)</span></div>
  </div>
</body>
</html>
