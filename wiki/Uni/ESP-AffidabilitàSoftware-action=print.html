<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Elementi di Sicurezza e Privatezza - Affidabilità del software</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='ESP-Affidabilit%C3%A0Software.html' title='Elementi di Sicurezza e Privatezza - Affidabilità del software'>Elementi di Sicurezza e Privatezza - Affidabilità del software</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
<a class='wikilink' href='ElementiSicurezzaPrivatezza.html'>Torna alla pagina di Elementi di sicurezza e privatezza</a>
</p><hr />
<div class='vspace'></div><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: Affidabilità del software ::</strong>
</pre><div class='vspace'></div><div  style='text-align: left; background-color: #f5f9fc; width: 300px; border: 2px solid #cccccc; padding: 5px;' > 
<p  style='text-align: center;'><strong>Indice</strong>
</p>
<div class='vspace'></div><ol><li><a href='#a1'>Virus</a>
</li><li><a href='#a2'>Trapdoor</a>
</li><li><a href='#a3'>Salami attack</a>
</li><li><a href='#a4'>Attacchi su canali di comunicazione</a>
</li><li><a href='#a5'>Buffer overflow</a>
</li></ol></div>
<p class='vspace'><a name='a1' id='a1'></a>
</p><h2>Virus</h2>
<h3>Concetti generali</h3>
<p>Il <strong>virus</strong> è un software in grado di infettare altri programmi modificandoli in modo che ne contengano una copia al loro interno; ogni programma infetto agisce a sua volta come un virus. E' dunque composto da due parti, una che svolge le funzioni di <em>duplicazione</em> e l'altra quelle di <em>danneggiamento</em> (inteso come violazione della sicurezza, non necessariamente grave).<br />A seconda delle caratteristiche di attivazione, i virus si possono classificare in:
</p><ul><li><strong>transienti</strong>, quando la vita del virus dipende da quella del programma che lo ospita. In altre parole il virus è in esecuzione se e solo sé è in esecuzione il programma infetto
</li><li><strong>residenti</strong>, quando il virus è in memoria e rimane attivo o può essere attivato come un programma stand-alone, quindi indipendente dal programma infetto.
</li></ul><p class='vspace'>Un virus racchiude in sé le caratteristiche di alcuni tipi di <em>malware</em>, in particolare:
</p><ul><li>dei <em>cavalli di troia</em> condivide il fatto che entrambi inseriscono nei codici dei programmi infetti funzionalità non note. Notare che non è sempre vero che un trojan è anche un virus, dipende se si duplica o no
</li><li>come le <em>bombe logiche</em> può attivarsi al verificarsi di certi eventi o condizioni
</li><li>può permettere accessi non autorizzati al sistema proprio come le <em>trapdoor</em>
</li><li>con i <em>worm</em> ha in comune la proprietà di propagarsi all'interno del sistema centralizzato (quindi non necessariamente attraverso la rete)
</li><li>dei <em>rabbit</em> può condividere la finalità di replicare sé stesso per saturare le risorse del sistema
</li></ul><p class='vspace'>Il codice malizioso dei virus viene attivato solo una volta mandato in esecuzione, dopodiché infettano attaccandosi o sostituendosi ad una porzione di codice. In base alle strategie di infezione distinguiamo virus che attaccano il programma <em>esternamente</em> (<strong>non sovrapposto</strong>), che lasciano il programma utilizzabile ma intanto gli aggiungono istruzioni dannose (quindi il programma infetto avrà una dimensione maggiore rispetto a prima), e virus che attaccano <em>internamente</em> (<strong>sovrapposto</strong>) che effettuano un replacement delle istruzioni del programma, rendendolo di fatto inutilizzabile. Nelle due figure successive viene rappresentata visivamente questa distinzione, illustrando la situazione prima dell'infezione (a sinistra) e dopo (a destra); in particolare, <strong>T</strong> rappresenta il programma originale, mentre la porzione <strong>V</strong> è quella infetta.
</p>
<p class='vspace'  style='text-align: center;'><em>Infezione sovrapposta</em><br /><img src='../uploads/Uni/infSovr.jpg' alt='' title='' />
</p>
<p class='vspace'  style='text-align: center;'><em>Infezione non sovrapposta</em><br /><img src='../uploads/Uni/infNONSovr.jpg' alt='' title='' />
</p>
<p class='vspace'>Perché un codice malizioso possa essere considerato virus, oltre alle caratteristiche viste finora deve inoltre:
</p><ul><li>essere difficile da individuare dagli antivirus
</li><li>essere difficile da cancellare o deattivare, perché se lo costruisci non vuoi che sia reso facilmente inoffensivo
</li><li>diffondersi rapidamente, cercando di infettare il maggior numero di sistemi informatici nel minor tempo possibile
</li><li>infettare non solo il programma che lo ospita
</li><li>essere facile da creare
</li><li>essere indipendente dal sistema operativo, anche se la maggior parte è dedicata ad uno ben preciso che inizia per W e finisce per indows
</li></ul><p class='vspace'>Esiste inoltre un tipo particolare di virus che attacca il <em>boot sector</em>, quindi infetta il sistema prima che qualsiasi antivirus possa entrare in esecuzione. La normale procedura di bootstrap prevede: accensione del computer e test dei componenti hardware, lettura del boot sector da hard disk, caricamento del bootstrap loader che carica il sistema operativo. In seguito all'infezione dei virus in questione si avrebbe invece: accensione del computer e test dei componenti hardware, esecuzione del virus, caricamento del boostrap loader che carica il sistema operativo col virus già in esecuzione.
</p>
<div class='vspace'></div><h3>Tecniche di rilevamento</h3>
<p>La maggior parte dei virus può essere identificata con una specifica stringa di bit, detta <em>firma del virus</em> o <strong>signature</strong>. La firma caratterizza i virus e può essere sfruttata dai software antivirus per la loro rilevazione, ma con riserva, dato che certe sequenze di bit potrebberero dare adito a falsi positivi.
</p>
<p class='vspace'>Ci sono diversi modi per riconoscere un virus, attraverso i <em>pattern di memorizzazione</em>, i <em>pattern di esecuzione</em> e i <em>pattern di trasmissione</em>. Vediamoli singolarmente.<br />I <strong>pattern di memorizzazione</strong> tengono in considerazione il fatto che il codice del virus può iniziare con una sequenza di byte invariante, che può rivelarsi una signature rintracciabile. Da notare che all'interno del programma infetto la porzione di codice contenente il virus non si trova necessariamente all'inizio, ma anche in fondo o dopo tot byte, comunque nella stessa posizione. Un altro pattern di memorizzazione sospetto potrebbe essere un programma il cui codice comincia con un'istruzione di jump, saltando subito altrove prima ancora di definire le variabili. I pattern di memorizzazione sono la tecnica di rilevazione più semplice da realizzare ed una delle più affidabili.<br />Considerare i <strong>pattern di esecuzione</strong> significa osservare il comportamento del virus una volta eseguito, in particolar modo le modalità di diffusione, le tecniche adottate per non essere individuato, l'entità e la tipologia dei danni provocati. Una tecnica di riconoscimento di questo tipo non è comunque banale, dal momento che modifiche al file directory potrebbero essere effettuate da processi non infetti in modo del tutto legittimo.<br />Infine, l'individuazione di un <strong>pattern di trasmissione</strong> si basa sul presupposto che un virus adotti sempre la stessa metodologia di diffusione, quindi è la diffusione stessa una signature. Piuttosto inefficace come strategia, dato che difficilmente un virus avrà un unico pattern di trasmissione.
</p>
<p class='vspace'>Gli antivirus si concentrano prevalentemente sui pattern di memorizzazione, ma dato che uno dei principali obiettivi dei programmatori di virus è non far scoprire le loro creature, esistono dei sistemi per mascherarne le signature. Una tecnica piuttosto diffusa è rendere <em>dinamica</em> la firma, continuando a cambiarla ad ogni infezione scegliendo tra un range limitato di stringhe alternative. L'evoluzione successiva è il <strong>virus polimorfo</strong>, che può assumere un numero elevato o illimitato di forme diverse. Non è sufficiente che utilizzi stringhe casuali se poi le inserisce sempre nella stessa posizione, o si potrebbe considerare come signature le parti che rimangono invariate; un virus polimorfo come si deve invece deve cambiare, suddividere e distribuire il proprio codice in varie porzioni del programma da infettare.<br />Un ulteriore raffinamento per rendere il rilevamento ancora più difficoltoso è fare sì che il virus polimorfo adoperi tecniche crittografiche per cambiare forma. Il <strong>virus crittografico</strong> è più complesso da realizzare, ed è composto da tre parti:
</p><ul><li>una <em>chiave di decrittazione</em> che varia da infezione a infezione
</li><li>il <em>codice crittato</em>, ovviamente
</li><li>una <em>routine in chiaro per la decrittazione del codice</em>, che potrebbe essere sfruttata come signature del virus
</li></ul><p class='vspace'>Ultima considerazione da fare sui virus è che il loro codice sorgente è tipicamente di piccole dimensioni, in modo da nascondersi facilmente in programmi più grossi. Confrontare infatti due istanze dello stesso programma una infetta e l'altra no, darebbe quasi sicuramente lo stesso risultato di un confronto tra due istanze "pulite". La procedura che determina se due programmi sono equivalenti rappresenta infatti un problema non decidibile dato che diversità nelle dimensioni potrebbero essere indotte da cause interne, quindi non legate all'azione dei virus.
</p>
<p class='vspace'><a name='a2' id='a2'></a>
</p><h2>Trapdoor</h2>
<p>Una <strong>trapdoor</strong> è un punto di ingresso non documentato ad un modulo o a un programma che un utente maligno potrebbe sfruttare per accedere al sistema (se fosse documentato probabilmente sarebbe anche protetto). La loro creazione avviene generalmente in buona fede, dal momento che vengono spesso inserite in fase di sviluppo del codice per testare il programma, o tenuti in seguito per manutenerlo; vanno però tolti una volta rilasciato il software, perché lasciano pericolosi buchi nella sicurezza.
</p>
<p class='vspace'>Un particolare tipo di trapdoor è quello legato a un controllo approssimativo degli errori all'interno di un programma, in particolare in riferimento ai dati in ingresso. Se non viene verificata l'ammissibilità dei dati in input, un utente malizioso potrebbe infatti causare effetti indesiderati nel sistema. E' ciò che accade con le <em>SQL injection</em>, dove l'attaccante sfrutta un punto di ingresso (ad esempio una form) per fornire una stringa SQL in grado di provocare danni al database (ad esempio una <code class='escaped'>drop table</code>). Controllare sempre che l'input sia quello che ci si aspetta è quindi un'ottima regola da applicare per garantire maggiore sicurezza (vedi più avanti per maggiori dettagli)
</p>
<p class='vspace'><a name='a3' id='a3'></a>
</p><h2>Salami attack</h2>
<p>Con il termine <strong>salami attack</strong> non ci si riferisce a un sistema ben preciso, ma è piuttosto la generalizzazione di una strategia per compiere illeciti. L'osservazione che sta alla base di questa tecnica è che i piccoli crimini informatici hanno maggior probabilità di sfuggire ai controlli rispetto a quelli più eclatanti; dunque si avvia una catena di piccoli attacchi che singolarmente passano inosservati, ma nel complesso provocano danni significativi.
</p>
<p class='vspace'>L'esempio classico è quello del programma che gestisce le transazioni all'interno di una banca, e che per forza di cose avrà spesso a che fare con delle approssimazioni. Un programmatore malintenzionato potrebbe fare in modo di trasferire tali scarti monetari su un altro conto: si tratta di millesimi, ma dai e dai diventano una fortuna. <br />La stessa tecnica si può applicare a diversi contesti, non solo a quello monetario. Ad esempio con procedimenti analoghi si possono intercettare delle informazioni.
</p>
<p class='vspace'><a name='a4' id='a4'></a>
</p><h2>Attacchi su canali di comunicazione</h2>
<p>Le comunicazioni hanno normalmente luogo attraverso canali legittimi stabiliti dal sistema per far colloquiare le parti in gioco. A questi canali se ne possono aggiungere altri non convenzionali, detti <strong>covert channel</strong> (<em>canale coperto</em>), in grado di operare secondo protocolli di comunicazione inusuali e insospettati. Possono essere utilizzati per trasferire informazioni che violano le politiche di sicurezza, ma anche per sfuggire alle analisi del traffico web, come accade con il software <em>Tor</em>.
</p>
<p class='vspace'>Un tipo di canale coperto che sfrutta la presenza o l'assenza di oggetti in memoria per sottrarre informazione è lo <strong>storage channel</strong>. Alcuni esempi:
</p><ul><li>il canale <em>file lock</em> segnala in un bit di informazione se in un sistema multiutente un file è bloccato (quindi usato), oppure no
</li><li>con la <em>quota disco</em> avviene invece un tentativo da parte del programma spia di creare un file di grosse dimensioni. Se ci riesce significa che c'è ancora spazio disponibile sul disco, altrimenti significa che è occupato da qualcos'altro
</li><li>uno storage channel che verifica l'esistenza di un file, semplicemente cercando di aprirlo
</li></ul><p>Qualsiasi tecnica decidessimo di utilizzare, è comunque sottointeso che il programma spia dovrà avere accesso alle risorse condivise del sistema, e se in particolare vorrà intercettare le comunicazioni di un programma di servizio, dovrà condividere con lui anche la nozione di tempo.
</p>
<p class='vspace'>Vediamo infine il <strong>timing channel</strong>, più subdolo e complesso, che spia se i programmi di servizio usano o meno il tempo di computazione ad essi assegnato dal sistema operativo, ottenendo sempre 1 bit di informazione per rilevazione (se il tempo di computazione assegnato viene usato allora si segnala 1; s il tempo non viene usato si segnala 0). Basta pensare alla quantità di processi normalmente attivi in un ambiente multitasking per rendersi conto dell'estrema complessità di questa strategia.
</p>
<div class='vspace'></div><h3>Identificare i covert channel</h3>
<p>Individuare i covert channel è un'operazione per niente banale, dato che essi sfruttano sistemi ordinari (standard) per ottenere le informazioni da dare in pasto ai programmi spia. Una tecnica consiste nell'analizzare come vengono utilizzate le risorse condivise dai vari processi in esecuzione nel sistema, dato che sono le uniche su cui può interferire un covert channel. Si costruisce una matrice (ideata da <em>Kemmerer</em>) in cui le righe sono le risorse e le colonne i processi; per ogni cella si scrive poi <strong>R</strong> se il processo <em>j</em> può leggere o osservare la risorsa <em>i</em>, o <strong>M</strong> se invece può accedervi in scrittura. Le condizioni perché ci sia un covert channel sono:
</p><ol><li>due o più processi devono avere accesso ad una risorsa in comune
</li><li>almeno uno dei processi coinvolti deve essere abilitato per l'accesso in scrittura su tale risorsa
</li><li>la scrittura sulla risorsa utilizza informazioni prelevate da altre risorse cui il processo ha legittimo accesso
</li></ol><p>Un esempio in figura:
</p>
<div class='vspace'></div><div  style='text-align: center;'><img src='../uploads/Uni/MRC1.jpg' alt='' title='' /></div>
<p class='vspace'>Questa situazione è sospetta, in quanto se la modifica di R2 da parte di P2 è legata alla lettura della risorsa R5, il processo P5 accede ad essa indirettamente. Potremmo cioè avere la seguente situazione:
</p>
<div class='vspace'></div><div  style='text-align: center;'><img src='../uploads/Uni/MRC2.jpg' alt='' title='' /></div>
<p class='vspace'>Abbiamo parlato di <em>sospetti</em>, perché di questi si tratta: una volta individuati i flussi potenziali di informazione, essi vanno studiati. Possiamo così avere quattro scenari:
</p><ul><li>tali flussi sono legali
</li><li>tali flussi non comportano il passaggio di informazioni di interesse tra i processi
</li><li>i processi mittente e ricevente sono lo stesso
</li><li><em>abbiamo rilevato un covert channel!</em>
</li></ul><p class='vspace'>Denning ha ideato un altro sistema per identificare i covert channel, l' <strong>analisi del flusso di informazione</strong>, che analizza direttamente le istruzioni di un programma. Studiando il codice sorgente dei programmi si possono infatti scoprire flussi di informazione non ovvi tra le varie istruzioni. Un esempio di flusso esplicito è un normale assegnamento, ad esempio in <code class='escaped'>B := A</code> le informazioni vanno da A a B. Un flusso implicito è invece quello che va da D a B nell'istruzione: <code class='escaped'>if (D == 1) then B := A</code> , se B effettua l'assegnamento è perché sa che D è pari a 1. Un ultimo esempio di flusso implicito è quello delle chiamate di funzione, che generalmente assegnano sempre valori di ritorno. C'è da ricordare però che i flussi impliciti non sono necessariamente legati a tentativi di violazione, ma bisogna comunque porvi le dovute attenzioni.
</p>
<p class='vspace'><a name='a5' id='a5'></a>
</p><h2>Buffer overflow</h2>
<p>I <em>bug</em> sono errori nel codice del software che possono essere sfruttati per violare la sicurezza del sistema. Per quanto un programmatore possa prestare attenzione al proprio lavoro, i bug sono praticamente inevitabili; cionondimeno (!!!) ne esistono alcuni tipici abbondantemente documentati e decisamente da evitare. Uno di questi è il <strong>buffer overflow</strong> (<em>BOF</em>).
</p>
<p class='vspace'>Il <strong>buffer</strong> è una porzione di memoria (stack e heap) usata per memorizzare temporaneamente i dati utilizzati dai vari programmi, ha una dimensione ben precisa e generalmente non effettua alcun controllo su ciò che contiene. Per <em>overflow del buffer</em> si intende inserirvi più dati di quanti ne possa in realtà contenere, il che comporta una sovrascrittura delle zone di memoria adiacenti e dunque potenziali vulnerabilità. Programmatori maliziosi potrebbero infatti sfruttare il BOF per sovrascrivere codice eseguibile nello stack per prendere possesso del sistema, o comunque "scombinare" i dati nel buffer in modo tale che il programma non funzioni più correttamente. I buffer overflow avvengono generalmente nel contesto di chiamate di funzione, di cui vengono alterati i valori degli indirizzi di ritorno e dell'istruzione successiva inficiando la normale esecuzione.
</p>
<p class='vspace'>Vediamo ora un esempio.<br />Abbiamo la seguente porzione di codice, che copia all'interno di un array di dimensione 126 il contenuto di un altro array passato come parametro:
</p>
<div class='vspace'></div><pre class='escaped'>void func(char *str)
{
  char buf[126];
  strcpy(buf, str);
}</pre>
<p class='vspace'>La chiamata di questa funzione provoca l'inserimento di un nuovo frame nello stack, dove per frame si intende una sequenza di dati.
</p>
<div class='vspace'></div><div  style='text-align: center;'><img src='../uploads/Uni/bof1.jpg' alt='' title='' /></div>
<p class='vspace'>L'area di memoria puntata da <code class='escaped'>str</code> è inserita nello stack, ma se la sua lunghezza è superiore a 126 byte allora la stringa andrà a sovrascrivere le celle adiacenti. Nella figura sotto vediamo che andrà a sovrapporsi all'area contenente l'indirizzo di ritorno.
</p>
<div class='vspace'></div><div  style='text-align: center;'><img src='../uploads/Uni/bof2.jpg' alt='' title='' /></div>
<p class='vspace'>Se la stringa data in pasto al programma era stata creata ad hoc per violare la sicurezza attraverso un attacco di tipo buffer overflow, l'area appena sovrascritta potrebbe contenere un nuovo puntatore che indirizza a una porzione di codice malizioso.
</p>
<div class='vspace'></div><div  style='text-align: center;'><img src='../uploads/Uni/bof3.jpg' alt='' title='' /></div>
<p class='vspace'>Dall'esempio possiamo trarre alcune conclusioni aggiuntive rispetto alle considerazioni precedenti:
</p><ul><li>l'attaccante deve indovinare o conoscere esattamente la posizione nello stack in cui si troverà il buffer quando verrà chiamata la funzione, o il suo tentativo non porterà ai risultati (da lui) sperati
</li><li>in questo caso è stata sfruttata una vulnerabilità della funzione <code class='escaped'>strcopy()</code>, che fa parte della libreria <code class='escaped'>string.h</code> del linguaggio C. Esempi di altre funzioni insicure sono <code class='escaped'>strcat()</code>, <code class='escaped'>gets()</code>, <code class='escaped'>scanf()</code>, <code class='escaped'>printf()</code>
</li><li>la vulnerabilità delle funzioni dipende dal linguaggio di programmazione utilizzato
</li><li>notare come un overflow di 1 byte non avrebbe cambiato l'indirizzo di ritorno, ma il puntatore al frame precedente (<em>overflow <strong>off-by-one</strong></em>)
</li></ul><p class='vspace'>Evitare il BOF non è un compito particolarmente ingrato, sono sufficienti alcuni accorgimenti
</p><ul><li>prima di tutto bisogna implementare delle routine di controllo della correttezza dei dati in input, facendo in modo tra le altre cose che l'utente non possa inserirne più del dovuto 
</li><li>randomizzare la posizione dello stack o crittare l'indirizzo di ritorno potrebbe essere una buona idea, dato che non permetterebbe all'attaccante di conoscere quale indirizzo di ritorno usare nella sua stringa maliziosa. 
</li><li>altro accorgimento è rendere lo spazio dello stack non eseguibile, impostando opportunamente il bit NX (<em>no execute</em>) per tale area di memoria. 
</li><li>una soluzione alternativa e definitiva è usare linguaggi di programmazione sicuri, ad esempio Java, che rilevano le condizioni anomale e interrompono l'esecuzione del programma.
</li></ul><div class='vspace'></div><hr />
<p><a class='wikilink' href='ElementiSicurezzaPrivatezza.html'>Torna alla pagina di Elementi di sicurezza e privatezza</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/ESP-Affidabilit%e0Software)</span></div>
  </div>
</body>
</html>
