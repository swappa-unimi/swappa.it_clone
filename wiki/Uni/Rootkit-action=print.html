<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Rootkit</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='Rootkit.html' title='Rootkit'>Rootkit</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
<a name='su' id='su'></a>
<a class='wikilink' href='GestioneDegliIncidentiInformatici.html'>Torna alla pagina di Gestione degli incidenti informatici</a>
</p><hr />
<p class='vspace'  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'><strong>:: Rootkit ::</strong>
</p>
<div class='vspace'></div><div class='frame' > 
<p>Ove non meglio specificato, tutti i testi tra virgolette vanno intesi come citazioni letterali dalle slide del prof <a class='wikilink' href='DarioForte.html'>Dario Forte</a>, 2008.
</p></div>
<div class='vspace'></div><h2>Definizione</h2>
<p>I <strong>rootkit</strong> sono binari/eseguibili/librerie il cui compito è garantire all'intruder la permanenza nel sistema; rappresentano la fonte più comune di <em>compromissione</em>, ovvero l'insieme di circostanze che portano l'attacker a prendere possesso della macchina.<br />Fissiamo dunque il concetto: la macchina si <code class='escaped'>buca</code> con l' <em>exploit</em> e si <code class='escaped'>compromette</code> con i rootkit.
</p>
<p class='vspace'>Questo genere di malware ha avuto un boom nella seconda metà degli anni '90, ma in alcune comunità erano già noti dal decennio precedente; uno in particolare - <code class='escaped'>log cleaner</code> - aveva dimostrato che fonti di prova come i log, normalmente considerati trusted, potevano in realtà essere a loro volta compromessi, specie se salvati in locale.
</p>
<div class='vspace'></div><h2>Tipologie</h2>
<p>I rootkit potrebbero essere classificati in base alle loro <strong>implementazioni</strong> e <strong>funzionalità</strong>.
</p>
<p class='vspace'>Considerando le funzionalità, ogni rootkit ne ha una specifica, e anche due della stessa tipologia possono avere numerosissime variabili che li differenziano: solo colui (o colei) che l'ha realizzato può averne un quadro completo. Ciononostante è possibile ricondurli tutti (o quasi) a tre possibili scopi alternativi:
</p>
<div class='vspace'></div><ul><li><strong>mantenere l'accesso al sistema</strong>, generalmente sfruttando l'esistenza di backdoor
</li><li><strong>utilizzare il sistema come testa di ponte</strong>, ovvero utilizzarlo come tramite per attacchi verso altri sistemi
</li><li><strong>cancellare le tracce</strong> lasciate dall'intrusione. Ad esempio se il rootkit agisce in locale potrebbe cancellare il log, mentre da remoto potrebbe disabilitare il daemon che ne tiene traccia
</li></ul><p class='vspace'>Da notare che i primi due casi sono legati a problemi di segretezza, mentre l'ultimo è un problema di incident management.
</p>
<p class='vspace'>Per quanto riguarda le implementazioni potremmo distinguerli in:
</p><ul><li><strong>binary rootkit</strong>, che vanno a sostituire alcuni binari del sistema con versioni alterate degli stessi. Sono chiamati anche <em>User Land rootkit</em>
</li><li><strong>kernel rootkit</strong>, che utilizzano moduli del kernel costruiti su misura per nascondere la presenza degli intruder
</li><li><strong>library rootkit</strong>, che fanno uso delle librerie di sistema per i loro fini
</li><li><strong>blended rootkit</strong>, che combinano le tre strategie appena viste
</li></ul><p class='vspace'>Storicamente ci si sta muovendo dai <em>binary rootkit</em> ai <em>kernel rootkit</em>. I primi infatti risiedono nel file system, dunque sono relativamente semplici da rilevare grazie alle <em>signature</em> che caratterizzano il loro codice; la ricerca avviene con meccaniche già note per altri malware, come i virus. I secondi invece sono infinitamente più dinamici, dato che i moduli del kernel sono caricati all'occorrenza e dunque non rilevabili se non con un apposito modulo di controllo caricato in RAM (ovviamente, non statico).
</p>
<p class='vspace'>Approfondiamo questi tre tipi di rootkit.
</p>
<div class='vspace'></div><h3>Binary rootkit</h3>
<p>Abbiamo già detto che i primi rootkit a comparire sono stati quelli di tipo <em>binary</em>, anche detti <em>user land rootkit</em>. La tecnica da loro utilizzata è sostituire i binari di sistema più critici (come <code class='escaped'>bin/login</code>) o i daemon di rete con altri creati su misura per la compromissione della macchina, ovvero trojan e/o binari progettati per raccogliere informazioni sullo stato dei processi e della rete.
</p>
<p class='vspace'>A seconda dei loro obiettivi possiamo suddividerli in cinque categorie:
</p><ul><li>quelli che garantiscono un accesso privilegiato al sistema da remoto
</li><li>quelli che garantiscono un accesso locale privilegiato
</li><li>quelli che permettono di nascondere determinati processi
</li><li>quelli che permettono di nascondere determinati file
</li><li>quelli che permettono di nascondere alcune attività dell'utente
</li></ul><p class='vspace'>Come si può intuire le ultime tre tipologie hanno tra le loro finalità quelle di rimuovere o celare le digital evidence dal sistema.
</p>
<div class='vspace'></div><h3>Kernel rootkit</h3>
<p>I <em>kernel rootkit</em> lavorano ad un livello più basso di quelli appena visti, ed assumono generalmente la forma di moduli di sistema la cui funzione principale è sostituire le chiamate di sistema originali con versioni modificate. Queste potrebbero avere i seguenti scopi:
</p><ul><li>nascondere la presenza dell'attaccante in modo più efficace ed elusivo rispetto agli user land rootkit
</li><li>compromettere il corretto funzionamento del kernel, rendendolo di fatto imprevedibile e inaffidabile
</li><li>rendere inaffidabili tutti i comandi impartiti al sistema, dato che la loro esecuzione si baserà su informazioni errate impartite dal kernel
</li></ul><p class='vspace'>Esistono diverse varianti di questi rootkit, compatibili con molti dei sistemi operativi Unix-like: Linux, OpenBSD, FreeBSD, Solaris.
</p>
<div class='vspace'></div><h3>Library rootkit</h3>
<p>Un terzo tipo di rootkit è quello che lavora a livello di <em>librerie</em> di sistema, sostituendo quelle che vengono normalmente usate dal kernel per inviare informazioni ai moduli superiori (in particolare allo spazio utente). Le librerie alterate hanno come fine quello di filtrare tutti quei dati e quelle informazioni che l'attaccante non vuole far arrivare a certi processi, nascondendo in questo modo la sua presenza. Comandi come <code class='escaped'>ps</code> (lista statica dei processi in esecuzione) e <code class='escaped'>top</code> (lista dinamica dei processi in esecuzione) non restituirebbero dunque alcun indizio di compromissione.
</p>
<p class='vspace'>Per questo tipo di rootkit esistono poi delle varianti che li rendono ancora più difficili da scovare. Ad esempio alcuni di essi non sostituiscono l'intera libreria ma solo poche specifiche funzioni, così che modificando la configurazione del loro loader possano essere caricate al posto di quelle originali. Una tecnica implementativa su sistemi Linux è inserire il nome di una di queste librerie sostitutive in <code class='escaped'>/etc/ld.so.preload</code>, una cartella particolare dato che tutte le librerie ivi contenute hanno la precedenza su quelle standard.
</p>
<div class='vspace'></div><h3>Windows rootkit</h3>
<p>Gli user-land rootkit che girano sotto Windows non agiscono sostituendo i binari bensì le API, i driver e le DLL, così che qualsiasi programma le usi venga a sua volta compromesso. Le tecniche di mascheramento rimangono invece più o meno le stesse, quindi modifica delle chiavi di registro e di altre informazioni su file e processi.
</p>
<p class='vspace'>Alcuni esempi noti di rootkit nei sistemi Win32 sono <em>Nt Rootkit</em>, <em>FU Rootkit</em>, <em>AFX</em> e <em>Shadow Walker</em>.
</p>
<div class='vspace'></div><h2>Rilevazione</h2>
<p>Le tecniche con cui vengono rilevati i rootkit nel sistema dipende dalla loro tipologia. Quando ad esempio abbiamo a che fare con gli <code class='escaped'>user land rootkit</code> un metodo potrebbe essere l'utilizzo di firme per il riconoscimento di eventuali binari alterati, operazione eseguibile con una semplice scansione del file system. Proprio per questa facilità di rilevamento questi rootkit sono considerati di basso livello, quindi avere il sistema compromesso da uno di essi è indice di una preparazione all'incident management inadeguata.<br />Quando invece si ha a che fare con rootkit avanzati (a livello di kernel, libreria o entrambi) bisogna effettuare controlli più specifici, scansionando ad esempio la RAM e controllando il flusso informativo. Tecniche più recenti si basano sul controllo del flusso esecutivo, ovvero si controlla il funzionamento del programma a livello di istruzioni eseguite e se si riscontrano comportamenti anomali li si considera indice di eventuale presenza di un rootkit.
</p>
<p class='vspace'>Concludiamo il paragrafo con una considerazione sulla <strong>time based security</strong>, composta da tre fattori: <em>protection time</em> (PT), <em>detection time</em> (DT) e <em>reaction time</em> (RT). Quando si pianifica il sistema di sicurezza non bisogna porsi tanto l'obiettivo di impedire ogni possibile attacco (sarebbe impossibile), ma di far perdere all'intruder il maggior tempo possibile così da avere più tempo per la detection. La regola aurea in questi casi è che: <strong>il PT deve sempre essere maggiore o uguale alla somma di DT e RT</strong>, ovvero bisogna far perdere all'attacker abbastanza tempo per bloccarlo.
</p>
<div class='vspace'></div><hr />
<p><a class='wikilink' href='GestioneDegliIncidentiInformatici.html'>Torna alla pagina di Gestione degli incidenti informatici</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/Rootkit)</span></div>
  </div>
</body>
</html>
