<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Temi Desame</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='TemiDesame.html' title='Temi Desame'>Temi Desame</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
<a class='wikilink' href='Crittografia.html'>Torna alla pagina di Crittografia</a>
</p>
<div class='vspace'></div><pre> <span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'><strong>:: Esercizi di Crittografia ::</strong></span>
</pre><p class='vspace'>Esercizi svolti by Licia
</p>
<p class='vspace'>Premetto che tra apici e pedici da sistemare sto sclerando abbastanza.. e molto probabilmente non li avrò sistemati tutti.. quindi se qualche anima pia si dovesse accorgere che qualcuno non è stato sistemato lo ringranzio.. 
</p>
<div class='vspace'></div><div  style='text-align: left; background-color: #f5f9fc; width: 215px; border: 2px solid #cccccc; padding: 5px;' > 
<p  style='text-align: center;'><strong>Indice</strong>
</p>
<div class='vspace'></div><ol><li><a href='#s1'>Cifratura classica</a>
</li><li><a href='#s2'>Cifratura simmetrica</a>
</li><li><a href='#s3'>Cifratura asimmetrica</a>
</li><li><a href='#s4'>Funzioni MAC</a>
</li><li><a href='#s5'>Funzioni HASH</a>
</li><li><a href='#s6'>Firme digitali</a>
</li><li><a href='#s7'>Certificati digitali</a>
</li><li><a href='#s8'>Scambio di chiavi: Diffie-Hellman</a>
</li><li><a href='#s9'>Secret Sharing</a>
</li></ol></div>
<p class='vspace'><a name='s1' id='s1'></a>
</p><h2>Cifratura classica</h2>
<h3>Vigenere</h3>
<p  style='text-align: center;'><em>APPELLO DEL 15/02/2011</em>
</p>
<p class='vspace'><span  style='color: red;'><strong>FATTO IN AULA</strong></span>
</p>
<p class='vspace'><strong>a) Si descrivano le caratteristiche del cifrario di Vigenere</strong>
</p>
<p class='vspace'>Il cifrario di Vigenere è un cifrario a sostituzione polialfabetica. Dato un testo in chiaro M ed una chiave di lunghezza n, si divide il testo in chiaro in blocchi di n caratteri, pari alla lunghezza della chiave; per crittografare un messaggio, la chiave deve essere lunga quanto il messaggio stesso e poiché di solito la chiave è di lunghezza minore del messaggio, viene ripetuta. Grazie alla ripetizione della chiave, il vantaggio di questo sistema di cifratura è che  due o più lettere uguali nel messaggio in chiaro potranno essere cifrate in modo differente. La crittoanalisi mediante frequenza delle lettere risulta quindi limitata.
Per poter crittografare/decrittografare il messaggio in chiaro/cifrato veniva utilizzata per semplicità una matrice di 26x26 ( le 26 lettere dell’alfabeto) in cui si ricercava la coppia “carattere del testo in chiaro – carattere della chiave”. 
Ora si possono utilizzare le seguenti formule: 
</p>
<p class='vspace'>crittografia : Ci = (Mi + K i mod t ) mod t
</p>
<p class='vspace'>Decrittografia: Mi = (Ci – K i mod t ) mod t
</p>
<p class='vspace'>dove t = lunghezza della chiave = 26, Mi = carattere del testo in chiaro 
Ci = carattere cifrato ( a = 0, b = 1 ….  Z = 25), K = chiave                                                                                
</p>
<p class='vspace'><strong>b) Descrivere il significato e l’utilizzo degli indici di coincidenza e mutua coincidenza nella crittoanalisi del cifrario di Vigenere</strong>
</p>
<p class='vspace'><em>INDICE DI COINCIDENZA (IC)</em>:  è utilizzato per calcolare la probabilità che due caratteri presi a caso in una stringa x1x2…xn siano uguali. Il suo utilizzo nella crittoanalisi serve per determinare la lunghezza della chiave. Grazie a questo indice è anche possibile capire in che lingua è stato scritto il messaggio in chiaro.
</p>
<p class='vspace'><em>INDICE DI MUTUA COINCIDENZA (MIC)</em>: è utilizzato per calcolare la probabilità che due caratteri presi a caso in una stringa x1x2…xn e in un’altra stringa y1y2…yn siano uguali. Il suo utilizzo nella crittoanalisi serve per determinare il valore della chiave
</p>
<p class='vspace'><strong>c) Si calcoli IC della parola “caccia”</strong>
</p>
<p class='vspace'>Formula:  [&#8721; da i=0 a i=25 fi*( fi – 1 )]/[n*( n – 1)]			
</p>
<p class='vspace'>frequenza f parola caccia : a = 2  c = 3  i = 1
</p>
<p class='vspace'>n = lunghezza della parola caccia = 6
</p>
<p class='vspace'>f0 = a = 2, (f1 = b = 0), f2 = c = 3, …. f8 = i = 1 …. (f25 = z = 0)
</p>
<p class='vspace'>quindi:
</p>
<p class='vspace'>IC =  [2 ( 2 – 1 ) + 3 ( 3 – 1 ) + 1 ( 1 – 1 )]/[6 ( 6 – 1)]   =  4/15  
</p>
<p class='vspace'><strong>d) Si calcoli MIC delle parole “birba” e “babbo"</strong>
</p>
<p class='vspace'>Formula:       [&#8721; da i=0 a i=25  (fi*fi')]/n*n'
</p>
<p class='vspace'>frequenza f parola birba:  a = 1   b = 2    i = 1   r = 1
</p>
<p class='vspace'>frequenza f' parola babbo: a’ = 1   b’ = 3  o’ = 1
</p>
<p class='vspace'>n = lunghezza della parola birba = 5
</p>
<p class='vspace'>n’ = lunghezza della parola babbo = 5
</p>
<p class='vspace'>f0 = a, f1 = b, …. f8 = i …. f14 = o, f17 = r, …
</p>
<p class='vspace'>MIC (birba, babbo)= [(1*1) + (2*3) + (1*0) + (1*0) + (1*0)]/(5*5) = 7/25
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 20/01/2011</em>
</p>
<p class='vspace'><strong>a) Si descriva la grandezza dello spazio delle chiavi dei seguenti cifrari</strong>
</p>
<p class='vspace'>i. <em>Cesare</em>: 25 possibili chiavi    
(non 26 xkè se sposto di 26 ritorna alla posizione iniziale e quindi non sposto nulla)
</p>
<p class='vspace'>ii. <em>Sostituzione (generica)</em>: 26! possibili chiavi (permutazione dei 26 caratteri)
</p>
<p class='vspace'>iii. <em>Vigenere</em>:  26^t  possibili chiavi ( dove t = lunghezza della chiave)
</p>
<p class='vspace'>iv. <em>Affine</em>:  26*12 possibili chiavi    
(b = [0,26], a = [1,12] – i valori di b sono le 25 lettere dell'alfabeto e i valori di a sono i numeri primi con 26 minori di 26)
</p>
<p class='vspace'>v.<em> Parole della chiave lunghe 10 lettere</em>:   26! / 16 ! possibili chiavi
</p>
<p class='vspace'>(perché il primo carattere viene scelto tra tutti i 26, il secondo carattere tra i 25 poichè è gia stato scelto il primo, ecc.. fino al decimo carattere della chiave, che viene scelto tra i 17 restanti e tutto diviso le 16 possibilità di caratteri mancanti)
</p>
<p class='vspace'><strong>b) Si consideri il cifrario di Cesare e si discuta l’eventuale vantaggio di adottare una doppia cifratura, cioè l’utilizzo in cascata di due chiavi k e k’ di cifratura</strong>
</p>
<p class='vspace'>Il cifrario di Cesare è un cifrario a sostituzione in cui ogni lettera dell’alfabeto corrisponde alla lettera che si trova a 3 posizioni in avanti dell’alfabeto:
per es. la A che si trova in posizione 0, verrà sostituita con la D che si trova in posizione 3, la B verrà sostituita con la E, la C con la F ecc.. ecc…
Quindi l’utilizzo di una doppia cifratura non ha nessuna maggiore sicurezza perché la somma di k e k’ corrisponderà ancora ad una singola sostituzione, solo che sarà di uno spostamento maggiore. 
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 10/09/2010</em>
</p>
<p class='vspace'><strong>a) Descrivere i principali tipi di attacco conosciuti e fornire un esempio per ciascuno scenario</strong>
Esistono 5 tipi di attacco:
</p>
<div class='vspace'></div><ol><li><strong>Known Ciphertext Attack</strong>: in cui l’avversario conosce solo il testo cifrato – esempio: se un testo è stato cifrato con il cifrario a sostituzione, un possibile attacco può essere l’analisi della frequenza dei caratteri, in cui è possibile risalire al testo in chiaro;(anche il cifrario di Vigenere è vulnerabile a questo attacco)
<div class='vspace'></div></li><li><strong>Known Plaintext Attack</strong>: in cui l’avversario conosce sia il testo in chiaro sia il testo cifrato – esempio: se un testo è stato cifrato con il cifrario di Hill, l’avversario può intercettare n² coppie di caratteri in chiaro e cifrati e impostare un sistema lineare che può (di solito) essere risolto facilmente
<div class='vspace'></div></li><li><strong>Chosen Plaintext Attack</strong>: in cui l’avversario può ottenere la cifratura di un testo in chiaro a sua scelta – esempio: crittografia a chiave pubblica, dove la chiave di cifratura è pubblica e l’attaccante può cifrare qualsiasi testo in chiaro egli voglia (x es. RSA)
<div class='vspace'></div></li><li><strong>Chosen Ciphertext Attack</strong>: in cui l’avversario può ottenere la decifratura di un testo cifrato a sua scelta – esempio: RSA, sfruttando le proprietà dell’omomorfismo e la cifratura dell’algoritmo
<div class='vspace'></div></li><li><strong>Chosen Text Attack</strong>: in cui l’avversario può ottenere la cifratura e la decifratura di coppie di testi in chiaro/cifrato – esempio??
</li></ol><p class='vspace'><strong>b) Descrivere le nozioni di algoritmo di cifratura incondizionatamente sicuro e computazionalmente sicuro</strong>
Un algoritmo di cifratura si definisce incondizionatamente sicuro se, indipendentemente dal tempo e dalle risorse disponibili, è impossibile decrittografare il testo cifrato; si definisce invece computazionalmente sicuro quando il tempo richiesto per violare la cifratura è grande e comunque superiore alla vita utile delle informazioni contenute
</p>
<p class='vspace'><strong>c) Discutere un sistema incondizionatamente sicuro di cifratura</strong>
Esiste un solo sistema di questo tipo, ed è il cifrario One-Time pad: si utilizza una chiave casuale di  lunghezza pari alla lunghezza del testo in chiaro, in modo da non doverla ripetere. La chiave deve essere utilizzata per crittografare e de crittografare un solo messaggio e poi essere scartata e cambiata. Questo schema è considerato inviolabile perché:
</p>
<p class='vspace'>- produce un output casuale che non ha più alcuna relazione statistica con il testo in chiaro;
</p>
<p class='vspace'>- la chiave è di lunghezza pari al messaggio e viene cambiata di volta in volta.
</p>
<p class='vspace'>Appunto per questi motivi però tale cifrario è utilizzabile sono in teoria e non in pratica poiché necessita di una grande quantità di chiavi casuali e vi è inoltre il problema di distribuzione delle chiavi poiché sia il mittente sia il destinatario devono essere a conoscenza della chiave.
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 09/02/2010</em>
</p>
<p class='vspace'><strong>a) Discutere la natura e i possibili attacchi al cifrario di Vigenere</strong>
Un possibile attacco a questo cifrario è il Known Ciphertext Attack, poiché conoscendo il testo cifrato è possibile utilizzare metodi statistici per risalire al messaggio in chiaro: utilizzando l’indice di coincidenza, in cui si risale alla lunghezza della chiave e utilizzando l’indice di mutua coincidenza per risalire alla chiave
</p>
<p class='vspace'><strong>b) Discutere la natura e i possibili attacchi al cifrario di Playfair</strong>
Un possibile attacco a questo cifrario è il Known Ciphertext Attack, poiché conoscendo il testo cifrato è possibile utilizzare metodi statistici per risalire al messaggio in chiaro: utilizzando l’analisi delle frequenze dei digrammi più comuni nella lingua
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 19/01/2010</em>
</p>
<p class='vspace'><span  style='color: red;'><strong>CHIESTO AL PROF.</strong></span>
</p>
<p class='vspace'><strong>b) Si supponga di tentare di rompere una cifratura, giocando il ruolo dell’avversario e conoscendo il tipo di sistema utilizzato per ottenere il messaggio cifrato. Quale plaintext si potrebbe utilizzare (in maniera ottimale) per determinare la chiave sapendo che il cifrario utilizzato è:</strong>
</p>
<p class='vspace'><strong>i. Cifrario a Sostituzione</strong>
</p>
<p class='vspace'><strong>ii. Cifrario di Vigenere</strong>
</p>
<p class='vspace'><strong>iii. Cifrario di Hill</strong>
</p>
<p class='vspace'><strong>iv. Cifrario Affine</strong>
</p>
<p class='vspace'>(Cioè io avversario devo mandare un testo in chiaro in modo tale da farmelo decifrare, con uno di questi cifrari, per poter risalire alla chiave)
</p>
<p class='vspace'>i. <em>Cifrario a sostituzione:</em>Invio un testo in chiaro con tutte le lettere dell’alfabeto (dalla a alla z) in modo tale da ottenere la cifratura corrispondente per ciascuna lettera
</p>
<p class='vspace'>ii. <em>Cifrario di Vigenere</em>:  Data una chiave di lunghezza k, invio un testo in chiaro di lunghezza k, poiché in Vigenere la chiave utilizzata è la stessa ripetuta più volte per renderla pari alla lunghezza del testo da cifrare 
</p>
<p class='vspace'>iii. <em>Cifrario di Hill:</em> Invio un testo di m lettere in chiaro, perché vengono sostituite con m lettere cifrate secondo m equazioni lineari; quindi ad ogni blocco di caratteri lunghi m si avrà una chiave lunga m
</p>
<p class='vspace'>iv. <em>Cifrario Affine</em>:(?? su questo non sono sicura poichè il prof. si è perso via) (è un particolare cifrario a sostituzione) Invio un testo in chiaro con tutte le lettere dell’alfabeto per ottenere la corrispondente lettera cifrata; in questo modo posso risalire alla chiave perché la chiave utilizzata è una coppia di interi a e b appartenenti a Z26 che soddisfa tale equazione di cifratura: E(pi) = (api + b) mod 26 , dove a ha valori minori di 26 e primi con 26, mentre b qualsiasi valore tra 0 e 25
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 25/09/2009</em>
</p>
<p class='vspace'><strong>a) Descrivere brevemente la cifratura di Playfair</strong>
</p>
<p class='vspace'>Il cifrario di Playfair è un cifrario a sostituzione che opera sui digrammi. I digrammi del testo in chiaro vengo tradotti in digrammi cifrati. Si usa una matrice 5x5 comprendente tutte le lettere dell’alfabeto (i e j unica casella). Si inserisce all’inizio della matrice la chiave utilizzata (senza ripetere le doppie) e poi si inseriscono tutte le lettere mancanti dell’alfabeto, in ordine (escludendo cioè quelle della chiave gia utilizzate). 
Il testo in chiaro viene cifrato due lettere alla volta nel seguente modo: 
</p>
<p class='vspace'>- si individuano le due lettere nella tabella, esse definiscono un rettangolo in cui ciascuna lettera sta in un angolo e l’altra nell’angolo opposto.  Queste lettere verranno cifrate con quelle che si trovano all’estremità del rettangolo nel lato orizzontale opposto.
</p>
<p class='vspace'>- Le lettere che stanno sulla stessa riga(o colonna) verranno sostituite con quelle che stanno immediatamente alla loro destra (o immediatamente sotto).
</p>
<p class='vspace'>- Le lettere ripetute vanno separate da una lettera di riempimento, generalmente la meno utilizzata nella lingua, in italiano x es. la Q o la X
</p>
<p class='vspace'>- Se l’ultimo digramma è incompleto perché formato da un solo carattere di testo in chiaro viene utilizzata la lettera di riempimento per completarlo.
La decifratura avviene al contrario.
</p>
<p class='vspace'><strong>b) Discutere i vantaggi rispetto alla cifratura monoalfabetica e le debolezze del sistema Playfair</strong>
</p>
<p class='vspace'>Il vantaggio rispetto alla cifratura monoalfabetica è che con Playfair si hanno 676 possibili digrammi (26x26), a differenza delle sole 26 lettere della monoalfabetica; dunque l’identificazione dei singoli digrammi è più difficile. Nonostante ciò, la debolezza di questo sistema è che la struttura del testo rimane identica, e quindi un attacco statistico come l’analisi delle frequenze dei digrammi più comuni nella lingua è valido contro Playfair
</p>
<p class='vspace'><strong>c) Utilizzare la parola chiave "viva i farabutti" per cifrare il testo in chiaro "giornalisti" e decifrare il testo cifrato "qpgruatfourn</strong>
</p>
<p class='vspace'><a class='urllink' href='../uploads/Uni/playfair.gif' title='' rel='nofollow'>Attach:playfair.gif</a>
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 11/07/2009</em>
</p>
<p class='vspace'><strong>a) Descrivere il funzionamento del cifrario di Hill</strong>
L’algoritmo del cifrario di Hill prende una sequenza di m lettere in chiaro e le sostituisce con m lettere di testo cifrato. La sostituzione è determinata da m equazioni lineari in cui a ciascun carattere viene assegnato un valore numerico ( a = 0, b = 1,… z = 25).
</p>
<p class='vspace'>Crittografia: C = KP
</p>
<p class='vspace'>Il testo cifrato si ricava moltiplicando la matrice con i valori della chiave k per il vettore colonna del testo in chiaro. La matrice K deve essere invertibile, altrimenti non si potrebbe eseguire la decrittografia.
</p>
<p class='vspace'>Per es. per m = 2,  il sistema può essere visto come:
</p>
<p class='vspace'>c1 = ( k1,1p1 + k1,2p2 ) mod 26
c2 = ( k2,1p1 + k2,2p2 ) mod 26 
</p>
<p class='vspace'>e può essere rappresentato in forma matriciale nel seguente modo:
</p>
<div class='vspace'></div><pre> &#9484;          &#9488; &#9484;    &#9488;   &#9484;    &#9488;
 &#9474; k11  k12 &#9474; &#9474; p1 &#9474;   &#9474; c1 &#9474;
 &#9474;          &#9474; &#9474;    &#9474; = &#9474;    &#9474; mod 26
 &#9474; k21  k22 &#9474; &#9474; p2 &#9474;   &#9474; c2 &#9474;
 &#9492;          &#9496; &#9492;    &#9496;   &#9492;    &#9496;
</pre><p class='vspace'>Dove pi indica i caratteri del testo in chiaro, ki i caratteri della chiave e ci i caratteri del testo cifrato.
</p>
<p class='vspace'>Decrittografia:   P = CK<sup>-1</sup>
Il testo in chiaro si ricava moltiplicando la matrice inversa K-1 per il vettore colonna di testo cifrato.
</p>
<p class='vspace'><strong>b) Discutere la sicurezza del cifrario di Hill rispetto a:</strong>
</p>
<div class='vspace'></div><pre>     <strong>i. ciphertext-only attack</strong>

    <strong>ii. known plaintext attack</strong>     <strong>(possibilmente con un esempio)</strong>
</pre><p class='vspace'>i. Se prendiamo m grande allora il cifrario di Hill risulta abbastanza sicuro contro attacchi ciphertext-only perché il numero degli m-grammi possibili diventa troppo grande per fare un’analisi statistica.
</p>
<p class='vspace'>ii. Risulta invece vulnerabile ad un attacco known plaintext per il seguente motivo:
- Se l’attaccante conosce la matrice X di testi in chiaro e la matrice Y di testi cifrati, sa risalire alla chiave nel modo seguente
</p>
<p class='vspace'>Y = K * X   (dove K * X è una moltiplicazione per matrici)
</p>
<p class='vspace'>Se questo è vero, allora è sicuramente vero che:
</p>
<p class='vspace'>Y * X<sup>-1</sup> = K * X * X<sup>-1</sup>  quindi essendo X * X<sup>-1</sup>  = I (identità) si può ricavare la chiave:
</p>
<p class='vspace'>Y * X<sup>-1</sup> = K * I  =&gt;   Y * X<sup>-1</sup> = K
</p>
<p class='vspace'>[Quindi sfruttando le proprietà della matrice identità, che è una matrice neutra in quanto qualsiasi matrice moltiplicata per I restituisce se stessa, si riesce a risalire alla chiave K (K*I = k)]
</p>
<p class='vspace'>Dalla matrice X riesce a risalire alla matrice inversa X-1 che, moltiplicata per                                        entrambi i membri dell’equazione, da come risultato proprio la chiave K.
</p>
<p class='vspace'><strong>c) Si consideri l’usuale corrispondenza tra l’alfabeto dei numeri ed i numeri da 0 a 25:</strong>
</p>
<p class='vspace'><strong>sia |  k11 k12 |</strong>
</p>
<p class='vspace'><strong>    |  k21 k22 |  la chiave usata ed “m1, m2, m3, m4” il plaintext.</strong>
</p>
<p class='vspace'><strong>Esprimere matematicamente il corrispondente testo cifrato “c1 c2 c3 c4”.</strong>
</p>
<p class='vspace'><strong>sia “k11 = 5, k12 = 12, k21 = 2, k22 = 5” la chiave data:</strong>
</p>
<p class='vspace'><strong>- cifrare “dito”</strong>
</p>
<p class='vspace'><strong>- decifrare “kemk”</strong> 
</p>
<p class='vspace'><a class='urllink' href='../uploads/Uni/HILL1.gif.jpeg' title='' rel='nofollow'>Attach:HILL1.gif</a>
<a class='urllink' href='../uploads/Uni/HILL2.gif.jpeg' title='' rel='nofollow'>Attach:HILL2.gif</a>
<a class='urllink' href='../uploads/Uni/HILL3.gif.jpeg' title='' rel='nofollow'>Attach:HILL3.gif</a>
</p>
<p class='vspace'><a name='s2' id='s2'></a>
</p><h2>Cifratura simmetrica</h2>
<p  style='text-align: center;'><em>APPELLO DEL 25/09/2010</em>
</p>
<p class='vspace'><strong>a) Discutere la seguente affermazione: “In un generico algoritmo di cifratura a sostituzione a blocchi di n bit, le dimensioni della chiave sono n*2<sup>n</sup>”</strong>
</p>
<p class='vspace'>Sapendo che: i cifrari a blocchi operano su blocchi di n bit in input per produrre blocchi di n bit in output; con blocchi di n bit di testo in chiaro ho 2n possibili valori del blocco; ogni blocco di testo in chiaro deve produrre un blocco cifrato univoco e che questa mappatura 1 a 1 viene fatta dalla chiave, si può quindi dedurre che servono 2n mappature e che ciascuna mappatura è composta da una sequenza di n bit. Quindi il valore totale della chiave è n*2<sup>n</sup>
La chiave di un generico algoritmo di cifratura a blocchi si esprime come una tabella di 2n righe e n colonne (grandezza della tabella n*2<sup>n</sup>)
</p>
<p class='vspace'>ESEMPIO:
se ho un blocco di 3 bit, ho i seguenti valori: 000, 001, 010, 011, 100, 101, 110, 111 = 24 = 8 valori.
Una possibile cifratura potrebbe essere questa:
</p><pre> 000 -&gt; 100
 001 -&gt; 101
 010 -&gt; 000
 011 -&gt; 110
 100 -&gt; 011
 101 -&gt; 111
 110 -&gt; 001
 111 -&gt; 010
</pre><p>La chiave, guardando questa tabella, è la colonna di destra. Devo infatti procedere così: il mio blocco ha valore 010, quindi prendo la 010-esima voce della tabella, e ho la sua cifratura. Si vede quindi che la colonna di destra è composta da 8 voci da 3 bit l'una: per l'appunto n*2<sup>n</sup>
</p>
<p class='vspace'><strong>b) Si considerino DES e AES e si calcoli lo spazio necessario per memorizzare le funzioni da loro realizzate in forma tabellare. Discutere quindi i vantaggi di utilizzare DES e AES.</strong>
Per “spazio necessario per memorizzare le funzioni da loro realizzate in forma tabellare” si intende la lunghezza della chiave e considerato quanto detto al punto a) risulta essere n*2<sup>n</sup>. 
Quindi sapendo che DES utilizza blocchi di 64bit la grandezza della tabella sarà 64*2<sup>64</sup> , mentre AES prevede 128bit, quindi la grandezza della tabella sarà 128*2<sup>128</sup>
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 09/02/2010</em>
</p>
<p class='vspace'><strong>a) Discutere vantaggi e svantaggi delle modalità operative di DES</strong>
Servono per cifrare testi più lunghi di 64bit.
</p>
<p class='vspace'>La prima modalità operativa di DES è l’ ELECTRONIC CODEBOOK CHAINING: è il modello più semplice in cui ciascun blocco in chiaro viene codificato in modo indipendente, sempre con la stessa chiave. 
<em>Vantaggi</em>: è il metodo più semplice e veloce ed eventuali errori non si propagano.
<em>Svantaggi</em>: usando sempre la stessa chiave, uno stesso blocco in chiaro viene cifrato allo stesso modo e quindi per messaggi lunghi non è sicuro perché soggetto ad attacchi di sostituzione.
</p>
<p class='vspace'>La seconda modalità è il CIPHER BLOCK CHAINING: vi è dipendenza tra i blocchi perché l’input si ottiene come XOR tra il blocco in chiaro corrente e il blocco cifrato precedente.
<em>Vantaggi</em>: a differenza dell’ECB, non si generano blocchi uguali in output grazie alla loro dipendenza; se si cambia un solo bit del messaggio originario, cambia di conseguenza tutto il rimanente messaggio; questo vincolo di dipendenza evita attacchi di sostituzioni dei blocchi.
<em>Svantaggi</em>: la dipendenza dei blocchi genera però un rallentamento del sistema e la propagazione di errori.
</p>
<p class='vspace'>La terza modalità è il CIPHER FEEDBACK con s bit. Non utilizza blocchi di 64bit ma lavora con segmenti di s bit &lt; 64. Anche in questo caso vi è dipendenza tra i blocchi poiché la cifratura del blocco precedente viene utilizzata per cifrare il blocco successivo.
<em>Vantaggi</em>: il valore di s può essere scelto a piacimento e il valore della cifratura viene prodotto subito. 
<em>Svantaggi</em>: per valori di s molto piccoli, il sistema diventa più oneroso e vengono propagati gli errori.
</p>
<p class='vspace'>La quarta modalità è l'OUTPUT FEEDBACK. La struttura è simile al CFB, l’unica differenza è che la cifratura del blocco corrente si esegue con l’output di DES del blocco precedente (e non il blocco cifrato). 
<em>Vantaggi</em>: Non si propagano gli errori di trasmissione dei bit.
<em>Svantaggi</em>: E’ più vulnerabile del CFB a modifica di flusso.
</p>
<p class='vspace'>La quinta e ultima modalità è il COUNTER. Si impiega un contatore delle dimensioni del blocco in chiaro, e viene incrementato per ogni blocco. 
<em>Vantaggi</em>: non vi è dipendenza tra i blocchi e quindi si possono eseguire in parallelo le cifrature di diversi blocchi. Se si conosce prima il contatore, si può pre-calcolare l’output del DES ed eseguire poi solo un’operazione di XOR; si ha un accesso causale, la sicurezza è dimostrabile ed è semplice in quanto richiede solo l'algoritmo di crittografia.
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 04/11/2010</em>
</p>
<p class='vspace'><strong>a) Discutere il vantaggio di utilizzare strutture Feistel in DES</strong>
I vantaggi di utilizzo delle strutture Feistel sono:
</p>
<p class='vspace'>- che la cifratura e la decifratura sono processi invertibili, in quanto la decifratura usa lo stesso algoritmo per la cifratura con l’unica differenza in cui le sottochiavi vengono applicate nell’ordine inverso. Questo semplifica enormemente l’implementazione;
</p>
<p class='vspace'>- l’alternanza di sostituzioni, permutazioni ed espansioni (grazie alla funzione di Feistel) che forniscono la cosiddetta diffusione e confusione, cioè rispettivamente l’espansione della struttura statistica del testo in chiaro (cioè assegnare più lettere del testo in chiaro ad una lettera di testo cifrato – es. bigrammi) e la complicazione della relazione esistente fra testo cifrato e la chiave.
</p>
<p class='vspace'><strong>b) Discutere il funzionamento e la sicurezza di DES doppio</strong>
Il DES doppio prevede che il messaggio in chiaro venga cifrato due volte (con l’algoritmo di DES) con due chiavi diverse in sequenza (una per ogni passo di cifratura).
In questo modo la lunghezza della chiave raddoppia passando da 56 a 56*2 = 112 bit, con un notevole incremento dello spazio delle chiavi. Dato in input un blocco x di 64bit del testo in chiaro e due chiavi k1 e k2 a 56bit, cifriamo x con la chiave k1 ed otteniamo un blocco A di 64bit; cifriamo poi A con la chiave k2 ed otteniamo il corrispondente testo cifrato Y: 
</p>
<p class='vspace'  style='text-align: center;'>Y = DESk2(DESk1(x))
</p>
<p class='vspace'>La decifratura è analoga alla cifratura, ma richiede l’applicazione delle chiavi in ordine inverso:
</p>
<p class='vspace'  style='text-align: center;'>X = DESk1<sup>-1</sup>(DESk2<sup>-1</sup>(y))
</p>
<p class='vspace'>Anche se può sembrare un sistema apparentemente più resistente, il DES doppio non aumenta la sicurezza del DES a singola cifratura, anzi esiste un algoritmo che è in grado di rompere tale cifrario dimostrando che è equivalente alla cifratura dello stesso messaggio con una sola chiave, ed è l’attacco Meet in teh Middle.
Quindi utilizzando questo attacco, anche se il DES doppio utilizza una chiave di 112bit può essere rotto con uno sforzo dell’ordine di 2<sup>56</sup>, come per il DES singolo. Per questo motivo il DES doppio non viene utilizzato in pratica.
</p>
<p class='vspace'><strong>c) Discutere l’attacco Meet in the Middle a DES doppio</strong>
(questo è un attacco di tipo Known Plaintext Attack)
Questo algoritmo si basa principalmente sul fatto che se  Y = DESk2(DESk1(x)), allora 
A = DESk1(x) = DESk2<sup>-1</sup>(y). Quindi si supponga di conoscere una particolare coppia ( P e C ) dove P è il testo in chiaro e C il testo cifrato, e di voler determinare la chiave (k1, k2)  utilizzata nella cifratura di P.  Per prima cosa viene cifrato P utilizzando tutte le 2<sup>56</sup> possibili chiavi k1, memorizzando i testi cifrati in una tabella ( che viene eventualmente ordinata). Successivamente viene decifrato C usando tutte le 2<sup>56</sup> possibili chiavi k2. Man mano che vengono prodotte le decrittografie, si confrontano i risultati con la tabella e si ricerca una corrispondenza. Quando viene trovata una corrispondenza, si esegue il test delle due chiavi risultanti contro una nuova coppia nota di testo in chiaro/testo cifrato (poiché non è detto che sia effettivamente la chiave corretta, in quanto vi è una probabilità di 2<sup>48</sup> collisioni). Se le due chiavi producono il testo cifrato corretto si tratta quasi sicuramente delle chiavi corrette poichè in questo caso la probabilità di collisioni è 2<sup>-16</sup>. 
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 12/09/2009</em>
</p>
<p class='vspace'><strong>b) Si supponga di utilizzare una funzione hash H al posto della funzione f in DES. Quali caratteristiche deve avere questa funzione? Dato che H non è invertibile, come è possibile che l’algoritmo di decrittografia funzioni?</strong>
</p>
<p class='vspace'>La funzione hash dovrà avere le seguenti caratteristiche:
- accetta un solo input di lunghezza variabile, quindi solo un blocco e non anche la chiave, e produce un output di lunghezza fissa;
</p>
<p class='vspace'>- non è una funzione invertibile 
</p>
<p class='vspace'>- deve essere impossibile trovare un altro input che dia lo stesso valore hash in output
</p>
<p class='vspace'>Anche se H non è invertibile, è comunque possibile che l’algoritmo di decrittografia funzioni in quanto, per la decrittografia in DES, non è necessario invertire la funzione F poiché sono i blocchi (destro e sinistro) ad essere invertiti.
</p>
<p class='vspace'><a class='urllink' href='../uploads/Uni/decifraturaDES.gif.jpeg' title='' rel='nofollow'>Attach:decifraturaDES.gif</a>
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 02/02/2010</em>
</p>
<p class='vspace'><strong>Si consideri un cifrario a blocchi che cifra un messaggio M = M1M2M3…Mn e produce un testo cifrato C = C0C1C2C3….Cn usando un numero casuale N ed una chiave K nel seguente modo:</strong>
<strong>C<sub>0</sub> = N</strong>
<strong>C<sub>i</sub> = Ek(Mi) XOR C<sub>i-1</sub> per i = 1,2,3…,n</strong>
</p>
<p class='vspace'><strong>a) Scrivere la funzione di decifratura</strong>
</p>
<p class='vspace'>C0 = N
</p>
<p class='vspace'>C1 = E<sub>k</sub>(M1) XOR C0
</p>
<p class='vspace'>C2 = E<sub>k</sub>(M2) XOR C1 ….
</p>
<div class='vspace'></div><div><img src='../uploads/Uni/cifratura.gif.jpeg' alt='' title='' /></div>
<p class='vspace'>La decifratura è la seguente
</p>
<p class='vspace'>M1 = D<sub>k</sub> (C1 XOR C0)
</p>
<p class='vspace'>M2 = D<sub>k</sub> (C2 XOR C1)….
</p>
<p class='vspace'>Quindi la funzione di decifratura è:  
Mi = D<sub>k</sub> (Ci XOR C<sub>i-1</sub>) per i = 1,2,3….,n
</p>
<div class='vspace'></div><div><img src='../uploads/Uni/decifratura.gif.jpeg' alt='' title='' /></div>
<p class='vspace'><a name='s4' id='s4'></a>
</p><h2>Funzioni MAC</h2>
<p  style='text-align: center;'><em>APPELLO DEL 21/06/2005</em>
</p>
<p class='vspace'><span  style='color: red;'><strong>FATTO IN AULA</strong></span>
</p>
<p class='vspace'><strong>b) Si consideri la seguente funzione hash h(M) definita per messaggi M {0,1}*. Sia W0(M) (risp, w1(M)) il numero di 0 (risp, di 1) presenti nel messaggio M. La funzione h(M) restituisce</strong>:
</p>
<div class='vspace'></div><pre>      |   1        se     w0(M) &lt; w1(M)
</pre><p class='vspace'>h(M) =    |        0       se     w0(M) &gt; w1(M)
</p>
<div class='vspace'></div><pre>      |   m1       se     w0(M) = w1(M) (dove M=m1m2m3…..)'''
</pre><p class='vspace'><strong>i)	Si calcoli il digest dei seguenti messaggi M1 = {00011}, M2 = {100101}, M3 = {00111}, M4 = {0101010101}.</strong>
</p>
<p class='vspace'>W0 indica gli zeri, mentre w1 indica gli uni. Se guardiamo i bit di ogni singolo messaggio, per es. M1 vediamo che M1 ha 3 zeri e 2 uni, quindi gli zeri sono maggiori degli uni, di conseguenza ci troviamo nel secondo caso: h(M1) = 0, idem per gli altri messaggi. Per M2 invece possiamo vedere che gli uni e gli zeri sono uguali, quindi siamo nel caso 3: h(M2) = m1, cioè è uguale al primo bit del messaggio M2 che è 1 (h(M) = 1), ecc….
</p>
<p class='vspace'><strong>ii) Si discutano le proprietà di sicurezza della funzione h(M) precedentemente descritta</strong>
</p>
<p class='vspace'><em>monodirezionalità</em>: è soddisfatta perché dal valore dell’hash non è possibile risalire al messaggio
<em>sicurezza debole</em>: non soddisfatta perché si può trovare un altro messaggio M che genera uno stesso hash
<em>sicurezza forte</em>: non soddisfatta perché si può trovare una coppia di messaggi M e M’ che generano lo stesso hash
</p>
<p class='vspace'><a name='s5' id='s5'></a>
</p><h2>Funzioni HASH</h2>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 20/01/2011</em>
</p>
<p class='vspace'><span  style='color: red;'><strong>CHIESTO AL PROF.</strong></span>
</p>
<p class='vspace'><strong>a) Si consideri la seguente funzione hash che opera su messaggi M lunghi 2m bit:</strong>
<strong>H0:{0,1}2m -&gt; {0,1}m e si costruisca la funzione hash H1:{0,1}4m -&gt; {0,1}m</strong>                                                                                     <strong>tale che se x è una stringa di bit x € {0,1}4m con x = (x1||x2) e x1, x2 € {0,1}2m</strong> <strong>allora</strong> 
</p><pre>                     <strong>H1(x) = H0(H0(x1)||H0(x2))</strong>
</pre><p class='vspace'><strong>i.	Se m = 4 e H0 è la funzione che somma in modulo le coppie di bit successive,                                           calcolare l’output di H1 se x = 0110 1100 0001 1000</strong>
</p>
<p class='vspace'><strong>ii.	Si discutano le proprietà di sicurezza della funzione H1</strong>
</p>
<p class='vspace'><strong>iii.	Si provi in generale che se H0 è collision resistant, lo è anche H1</strong>
</p>
<p class='vspace'>Riassunto dati:
</p><ul><li>x1 e x2 €{0,1}2m così che la loro concatenazione da ({0,1}2m || {0,1}2m) ={0,1}4m , che corrisponde infatti alla x che € a {0,1}4m
</li><li>x = 0110 1100 0001 1000, quindi x1 = 0110 1100 mentre x2 = 0001 1000
</li><li>H0 è la funzione che somma in modulo le coppie di bit successive: cioè si considerano le coppie di bit della x (di x1 e x2) e si sommano in modulo: 
</li></ul><pre>	es. 01 = 1, 00 = 0, 11 = 0, 10 = 1 
</pre><p class='vspace'>i)
Quindi se proviamo a sostituire tali valori nella funzione hash H1:
</p><pre>	H1(x) = H0(H0(x1)||H0(x2))
	      = H0(H0(0110 1100)||H0(0001 1000))
	      = H0[(1100)|| (0110)]
	      = 0011
</pre><p class='vspace'>ii)	-   La proprietà One-wayness è soddisfatta perché dall’output H1 = 0011 non sono in grado di risalire all’input dato dai due valori x1 e x2
-	La proprietà di sicurezza debole alle collisioni non è soddisfatta perché posso                       generare un altro input che mi dia lo stesso valore di ouput; questo è possibile perché se inserisco per es. un input formato dalla seguenza 1001 al posto di 0110 mi darà lo stesso output per come è costruita la funzione hash H0
-	La proprietà di sicurezza forte alle collisioni non è soddisfatta perché, come detto per la sicurezza debole, posso trovare una coppia di input che mi dia lo stesso output, sfruttando la costruzione della funzione di hash H0
</p>
<p class='vspace'>iii)	Se assumiamo che la funzione H0 sia collision resistance e per assurdo assumiamo che H1 non lo sia, per non soddisfare la proprietà di collision resistance dovremmo avere un input x’ che genera uno stesso output y’, ma, per avere uno stesso output, anche gli argomenti della funzione H1 non devono essere collision resistance,  e ciò non corrisponde perché noi abbiamo detto inizialmente che H0 era collision resistance; di conseguenza abbiamo dimostrato che, se H0 è collision resistance, lo è anche H1.
</p>
<p class='vspace'  style='text-align: center;'><em>APPELLO DEL 14/09/2010</em>
</p>
<p class='vspace'><span  style='color: red;'><strong>CHIESTO AL PROF.</strong></span>
</p>
<p class='vspace'>2. 
<strong>a) Si consideri la seguente funzione hash che fa uso di un robusto algoritmo di cifratura simmetrica Ek(m). Per un messaggio arbitrario m=(m1,….,mn), l’hash d è calcolato come d=Em1(IV) XOR Emn(IV), dove indica lo XOR i IV è un valore fissato.</strong>
</p>
<p class='vspace'><strong>i) Discutere le proprietà di sicurezza della funzione indicata. In particolare la one-wayness (sugg. Si consideri un messaggio con n=1) e la collision resistance (sugg. Si consideri un messaggio con n=3 dove m2=m3).</strong>
</p>
<p class='vspace'><em>Proprietà di One-wayness</em>: se n=1 si ha un solo blocco, cioè M = m1, quindi l’hash d = Em1(IV) e da questa funzione non si è in grado di risalire al messaggio in chiaro perché m1 è la chiave e quindi l’unico modo sarebbe rompere il cifrario e risalire alla chiave (cioè il blocco).
</p>
<p class='vspace'><em>Proprietà di collsion resistance</em>: se n=3 e m2=m3 l’hash è il seguente:
</p>
<p class='vspace'>d=Em1(IV) XOR Em2(IV) XOR Em3(IV) = Em1(IV)
</p>
<p class='vspace'>Poichè i blocchi m2 ed m3 sono uguali, per la proprietà dello XOR si eliminano e rimane solo la cifratura con chiave il blocco 1
</p>
<p class='vspace'>Quindi un messaggio M formato da 3 blocchi è come se corrispondesse ad un solo blocco, e di conseguenza è possibile calcolare un M’ formato da un solo blocco tale da poter trovare una collisione: 
</p>
<p class='vspace'>M = m1m2m3 -&gt; h(M) = Em1(IV)
M’ = m1    -&gt; h(M’) = Em1(IV)
</p>
<p class='vspace'>Quindi questa proprietà non è soddisfatta
</p>
<p class='vspace'><a class='wikilink' href='Crittografia.html'>Torna alla pagina di Crittografia</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/TemiDesame)</span></div>
  </div>
</body>
</html>
