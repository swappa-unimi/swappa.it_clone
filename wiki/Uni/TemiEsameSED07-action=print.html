<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Temi d'esame di Sistemi - 9/9/2005</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='TemiEsameSED07.html' title='Temi d'esame di Sistemi - 9/9/2005'>Temi d'esame di Sistemi - 9/9/2005</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
<a class='wikilink' href='Sistemi.html'>Torna alla pagina di Sistemi per l'elaborazione delle informazioni</a>
</p><hr />
<div class='vspace'></div><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: Temi d'esame di Sistemi - 9/9/2005 ::</strong>
</pre><div class='vspace'></div><h2>Esercizio 1</h2>
<p><strong>Un server TCP a connessione multipla è stato realizzato usando la socket library come segue:</strong>
</p>
<div class='vspace'></div><pre class='escaped'>
listen(sd,5); /* AL PIU’ 5 CONNESSIONI */
do
{
   nsd = accept(sd,&amp;(work.s),&amp;addrlen);
   pid = fork();
   if (pid == 0)
   {
      /* QUI IL PROCESSO FIGLIO GESTISCE IL DIALOGO USANDO IL DESCRITTORE 'nsd' */
      close(nsd);
      exit(0); /* end of child process */
   }
   else close(nsd); /* IL PADRE NON USA 'nsd' */
} while(1);
</pre>
<p class='vspace'><strong>Fornire lo pseudocodice di un’implementazione alternativa che usi la chiamata select() supponendo che il numero massimo dei possibili client sia pari a 3 e che il loro indirizzo di rete e porta siano noti a priori.</strong>
</p>
<p class='vspace'><span  style='color: red;'><span style='font-size:83%'><strong>SOLUZIONE</strong></span></span>
</p>
<p class='vspace'>Lato server dovrò creare tre socket e memorizzarli in un array <em>sockset</em>. A questo punto faccio la select:
</p>
<div class='vspace'></div><pre class='escaped'>
status = select (0, &amp;sockset, NULL, NULL, NULL);

// INIZIO CICLO SUI SOCKET DI SOCKSET
//per capire quali socket hanno richiesto l'accesso scorro l'array di sockset 
//e si applica fd_isset, che restituisce un valore non zero se il socket è stato marcato

if (FD_ISSET (sockset[i], &amp;sockset)) //verifica per ogni socket che siano arrivati dati
   handleTCPservice(socket[i]); //...se sì, chiama la funzione richiesta

// FINE CICLO
</pre>
<p class='vspace'>Commenti al codice:
</p><ul><li><em>select</em>:
<ul><li>il primo parametro, pur essendo definito come il numero di descrittori da esaminare, è posto a 0 perché nelle Winsock viene ignorato;
</li><li>l'ultimo NULL passato come parametro è relativo al timeout, ed è così settato perché do per scontato che non ci siano richieste in attesa;
</li><li>è una chiamata bloccante, in quanto rileva solo la presenza dei dati sul primo socket pronto;
</li><li>evito il controllo sulla corretta esecuzione della select, dando per scontato che qualcuno effettui una connessione su uno dei socket del sockset);
</li></ul></li><li><em>FD_ISSET</em>, restituisce un valore non zero se il socket esaminato è stato marcato. Quindi permette di capire quali socket hanno richiesto di essere serviti;
</li><li><em>handleTCPservice</em>() è una pseudo-funzione che si applica a un qualsiasi servizio richiesto dal client.
</li></ul><p class='vspace'>Da notare che se con la accept avevo un unico socket attivo, con la select ne avrò più di uno contemporaneamente. Inoltre, se la accept garantiva la simultaneità grazie alla fork (più client serviti alla volta), con la select ho invece un unico processo in esecuzione (che può dunque servire un solo handleTCPservice per volta).
</p>
<p class='vspace'>Tuttavia, nulla mi impedisce di utilizzare una fork anche nella select. In questo modo avrei sì la simultaneità, ma non è poi così indispensabile dato che usiamo la select quando ci sono pochi socket da gestire. Può avere un senso <strong>solo quando il tempo di servizio è alto</strong>, così invece di dover eseguire più volte lo stesso servizio (facendo aspettare gli altri client) lo smisto su processi diversi simultaneamente.
</p>
<p class='vspace'>Come si implementa?
</p>
<div class='vspace'></div><pre class='escaped'>
// CICLO PRIMARIO DI SELECT

status = select (0, &amp;sockset, NULL, NULL, NULL);

// CICLO SECONDARIO SUI SOCKET DI SOCKSET

   for(i=0; i&lt;=2; i++) //scandisco i tre socket e...
      if(FD_ISSET (sockset[i], &amp;sockset)) //...se c'è almeno un socket pronto...
         if((c = fork()) == 0) //...fai una fork, e nel processo figlio...
            handleTCPservice(sockset[i]); //...esegui il servizio chiamato
            //il socket verrà chiuso dentro la procedura di servizio

// FINE CICLO SECONDARIO

// FINE CICLO PRIMARIO
</pre>
<div class='vspace'></div><hr />
<div class='vspace'></div><h2>Esercizio 2</h2>
<p><strong>La più semplice API verso il DNS è quella fornita dalla socket library con le chiamate gethostbyname() e gethostbyaddr(). Spiegatene il significato e usatele per scrivere lo pseudocodice di un programma che fornisca la stessa funzionalità di query diretta del comando nslookup.</strong>
</p>
<p class='vspace'><span  style='color: red;'><span style='font-size:83%'><strong>SOLUZIONE</strong></span></span>
</p>
<p class='vspace'>Le <em>API</em> sono l'Interfaccia di Programmazione di un'Applicazione, ovvero un insieme di procedure disponibili al programmatore per svolgere un determinato compito. <em>Nslookup</em> (Name Server Lookup) è uno strumento presente in tutti i sistemi operativi che utilizzano il protocollo TCP/IP, e consente di effettuare delle query ad un server DNS per la risoluzione di indirizzi IP o Hostname. Posso in pratica ottenere da un dominio il relativo indirizzo IP o nome host e viceversa.
</p>
<p class='vspace'>La chiamata <em>gethostbyname</em>() riceve una struttura con il nome DNS di un host e ne restituisce una sockaddr. La chiamata <em>gethostbyaddr</em>() fa l'esatto contrario.
</p>
<p class='vspace'>L'implementazione di nslookup che propongo legge un argomento (opzione) da linea di comando: se è "-d" chiama gethostbyaddr(), se è "-i" chiama gethostbyname().<br />Da notare che nslookup non ha bisogno in realtà di queste opzioni, dal momento che se gli do un nome mi restituisce l'ip e viceversa.
</p>
<div class='vspace'></div><pre class='escaped'>
[...]

String *nome, *ipaddress; // per comodità non li gestisco come struct ma come string

if(argv[1] == "-d") // per brevità gestisco le stringhe per assegnamento, senza "strcmp()"
{
   ipaddress = argv[2]; // memorizzo l'ipaddress passato da linea di comando

   // Voglio ora ottenere il nome dall'indirizzo IP passato,
   // che andrà poi convertito nel tipo di rete opportuno

   if(!(status = gethostbyaddr(nome, ipaddress))
   //gli passo sia il nome che l'indirizzo perché durante l'interrogazione al DNS
   //devo verificare che esista un'effettiva corrispondenza tra indirizzo e nome
   {
      //...nel caso non esista corrispondenza,
      //il programma esce visualizzando l'errore
      perror("Resolver non presente");
      exit(-1);
   }
   else
   {
      //...se invece esiste corrispondenza, stampa a video il nome
      printf("%s", nome);
      exit(0);
   }
}

else if(argv[1] == "-i")
{
   nome = argv[2]; // memorizzo il nome passato da linea di comando

   // Voglio ora ottenere l'indirizzo IP dal nome passato, 
   // che andrà poi convertito nel tipo di rete opportuno

   if(!(status = gethostbyname(nome, ipaddress))
   //anche in questo caso vale il discorso delle corrispondenze fatto prima
   {
      perror("Resolver non presente");
      exit(-1);
   }
   else
   {
      //...se invece esiste corrispondenza, stampa a video l'indirizzo IP
      printf("%s", ipaddress);
      exit(0);
   }
}
</pre>
<p class='vspace'>Anche se non è richiesto, vediamo come potrebbe essere implementata l'interfaccia IDL.
</p>
<div class='vspace'></div><pre class='escaped'>
// interface header IDL per il DNS
[ uiid 12345 ... //calcolato opportunamente
  version(1.0)
]

// interface body
interface DNS {
  [out] int status gethostbyname ( [in] string nome, [in] ipaddress);
  ...
}
</pre>
<p class='vspace'>Analizziamo come è stato descritto il metodo remoto gethostbyname:
</p><ul><li><em>[out]</em>, indica che il valore di ritorno del metodo deve essere restituito dal server al client;
</li><li><em>int status</em>, specifica nome e tipo del valore di ritorno del metodo;
</li><li><em>gethostbyname</em>, è il nome del metodo remoto;
</li><li><em>[in]</em>, indica che il parametro seguente è passato dal client al server;
</li><li><em>string nome</em>, indica nome e tipo del parametro passato.
</li></ul><p class='vspace'>A questo punto compilo con <em>rpcgen</em> o <em>IDL-compiler</em> l'IDL appena creata, ottenendo tre file:
</p><ul><li><em>DNS.h</em> (o DNS_h.h), che è l'header file da includere sia nel client che nel server, che contiene le definizioni dei metodi remoti;
</li><li><em>DNS_c.c</em>, ovvero lo stub che gestisce la comunicazione con il server, da linkare al client;
</li><li><em>DNS_s.c</em>, ovvero lo skeleton che gestisce la comunicazione con il client, da linkare al server. 
</li></ul><p class='vspace'>Linkando client e server coi rispettivi stub e skeleton e compilando, ottengo due nuovi eseguibili che chiamerò clientrpc.exe e serverrpc.exe. Non mi resta che:
</p><ol><li>registrare l'interfaccia col portmapper del server (porta 111) in modo che il chiamante si connetta alla porta giusta, e lanciare serverrpc.exe .
</li><li>lanciare clientrpc.exe al posto del vecchio client.exe .
</li></ol><p class='vspace'>Scopriamo runtime un interfaccia nota, è una chiamata <ins> statica </ins>. C'è una identificazione runtime delle porte dell'interfaccia.<br /><br />
</p><hr />
<div class='vspace'></div><h2>Esercizio 3</h2>
<p><strong>Scrivete una richiesta HTTP/1.0 per la pagina default.htm sul server www.dti.unimi.it<br />Scrivete una richiesta sul server www.dti.unimi.it per la URL radice /, ma soltanto i byte da 0 a 300.</strong>
</p>
<p class='vspace'><span  style='color: red;'><span style='font-size:83%'><strong>SOLUZIONE</strong></span></span>
</p>
<p class='vspace'><strong>prima richiesta:</strong><br /><em>GET</em> /default.htm HTTP/1.0<br /><em>Host</em>: www.dti.unimi.it<br /><em>Connection</em>: close<br /><br />
<strong>seconda richiesta:</strong><br /><em>GET</em> / HTTP/1.1<br /><em>Host</em>: www.dti.unimi.it<br /><em>Range</em>: bytes=0-300<br /><em>Connection</em>: close<br /><br />
</p><hr />
<div class='vspace'></div><h2>Esercizio 4</h2>
<p><strong>Un sito Web di grande successo offre la registrazione degli utenti alla URL <a class='urllink' href='http://ebusiness.com/register.htm' title='' rel='nofollow'>http://ebusiness.com/register.htm</a>. Poichè la procedura consiste di 3 form da compilare una dopo l’altra, si vuol permettere all’utente di abbandonare la procedura di registrazione in ogni momento per riprendere quando lo desidera. Per evitare di sprecare risorse sul server, si desidera memorizzare lato server le sole registrazioni complete. Illustrate una tecnica a vostra scelta per risolvere il problema.</strong>
</p>
<p class='vspace'><span  style='color: red;'><span style='font-size:83%'><strong>SOLUZIONE</strong></span></span>
</p>
<p class='vspace'>Una tecnica per risolvere questo problema è quella dei cookie. I cookie sono file testuali contenenti attributi per simulare lo stato di una sessione HTTP. Possono servire per: informazioni generali (pagine visitate, prodotti cercati, preferenze, ecc / autenticazione senza ripetere il login.<br />Immaginiamo che in fondo alla pagina dopo i 3 form ci sarà un tasto di <em>invio</em>, quindi se l'utente compila tutte e tre le form le informazioni vengono inviate e salvate sul server.<br />Mentre se l'utente compila solo parzialmente i form sul server non viene salvato nulla, ma vengono utilizzati i cookie che conterranno le informazioni parziali inserite dall'utente. La prossima volta che l'utente accederà alla pagina il client controllerà la presenza dei cookie, se li rileva inserisce le informazioni nei vari campi compilati precedentemente.<br /><br />
</p><hr />
<div class='vspace'></div><h2>Domande:</h2>
<ol><li><strong>Se una pagina Web contiene 10 tag &lt;img ...&gt; quante connessioni TCP verranno aperte con http1.0 quando si accede alla pagina? quante con http 1.1?</strong>
</li><li><strong>Spiegare la differenza tra i protocolli POP e IMAP</strong>
</li><li><strong>Cos'è IIOP e che ruolo ha nel protocollo CORBA?</strong>
</li></ol><p class='vspace'><span  style='color: red;'><span style='font-size:83%'><strong>SOLUZIONE</strong></span></span>
</p>
<p class='vspace'><strong>1.</strong><br />In HTTP/1.0 ogni immagine o altro file è caricato come connessione differente. Quindi avrò 10 connessioni per ogni mmagine più una per la pagina richiesta, quindi 11 totali.<br />Invece in HTTP/1.1 viene fatto un <em>multiple-get</em> nella stessa connessione. Quindi avrò un unica connessione.<br /><ins> <em>NOTA HTTP:</em> </ins> se faccio connessioni web corte ( HTTP/1.0 ) non do il tempo di arrivare ad una dimensione ottimale della finestra, mentre con HTTP/1.1 arrivo prima ad una finestra ottimale TCP di connessione.<br />Infatti minore è la dimensione delle immagini, minore è la differenza tra HTTP/1.0 e HTTP/1.1. Se sono "grosse" fa differenza perché passo più tempo al livello ottimale della finestra.<br /><br />
<strong>2.</strong><br />Il protocollo IMAP ( Internet Messagge Access Protocol ) è un’alternativa a POP3.<br />Come POP3 definisce un’astrazione nota come casella postale, posta sul computer server. L’utente attiva un client IMAP che contatta il server per recuperare i messaggi.<br />La <strong>diversità</strong> tra i due protocolli sta nel fatto che IMAP permette di creare, cancellare o rinominare dinamicamente le caselle postali. IMAP fornisce inoltre una funzionalità estesa per il recupero e l’elaborazione dei messaggi. L’utente può ottenere informazioni su un messaggio o esaminare i campi dell’intestazione senza recuperare l’intero messaggio; inoltre, può cercare una stringa specificata e riprendere parti specifiche di un messaggio.<br /><em>(dal libro)</em><br /><br />
<strong>3.</strong><br />IIOP ( Internet Inter-ORB Protocol ) è un programma basato su CORBA ed è una particolare implementazione del protocollo GIOP che si avvale del protocollo TCP/IP per la realizzazione dello strato di trasporto dei messaggi tra oggetti remoti.<br /><ins> <em>NOTA:</em> </ins> Non mi pare che abbia mai fatto questa parte (o magari mentre la faceva stavo giocando a Quake :p). Però a <a target='_blank'  class='urllink' href='http://www.mokabyte.it/1998/12/iiop.htm' title='' rel='nofollow'>questo</a> link trovate qualche spiegazione interessante sul protocollo GIOP e IIOP.
</p>
<div class='vspace'></div><hr />
<p class='vspace'><a class='wikilink' href='Sistemi.html'>Torna alla pagina di Sistemi per l'elaborazione delle informazioni</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/TemiEsameSED07)</span></div>
  </div>
</body>
</html>
