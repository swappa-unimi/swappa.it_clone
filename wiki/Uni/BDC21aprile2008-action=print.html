<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / BDC - Lezione del 21 aprile 2008</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='BDC21aprile2008.html' title='BDC - Lezione del 21 aprile 2008'>BDC - Lezione del 21 aprile 2008</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
</p><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: BDC - Lezione del 21 aprile 2008 ::</strong>
</pre><p class='vspace'><a class='wikilink' href='BDComplementi.html'>Torna alla pagina di BDC</a>
</p>
<div class='vspace'></div><h1>Architetture distribuite</h1>
<p>Ci sono diversi paradigmi per distribuire i dati:
</p><ul><li>client - server
</li><li>db distribuiti: più server usati dalla stessa applicazione
</li><li>db paralleli: i compiti sono distribuiti
</li><li>db replicati
</li><li>data warehouse = gestiscono i dati dedicati al supporto alle decisioni (qualsiasi cosa esso sia)
</li></ul><p class='vspace'>E abbiamo 2 tipologie di architetture: <strong>OLTP</strong> e <strong>OLAP</strong>.
</p>
<p class='vspace'><strong>OLTP</strong> = OnLine Transaction Processing, ed è un'architettura specializzata nel gestire migliaia di transizioni al secondo secondo le proprietà ACID.
</p>
<p class='vspace'><strong>OLAP</strong> = OnLine Application Processing, è rivolta alle analisi dei dati per le Data Warehouse di cui sopra.
</p>
<p class='vspace'>Ma in generale, i server hanno sia funzioni OLTP che OLAP.
</p>
<p class='vspace'>Infine, ci sono delle proprietà che i sistemi distribuiti hanno (o dovrebbero avere):
</p><ul><li>portabilità = usando uno standard come SQL posso portare dati da un ambiente all'altro
</li><li>interoperabilità = posso far dialogare a run-time sistemi diversi
</li></ul><div class='vspace'></div><h2>Client - Server</h2>
<p>Il client fa la parte attiva, mentre il server quella passiva, in quanto ascolta le richieste del client e cerca di soddisfarle. In generale, il client vuole sapere poche cose alla volta, e tutte in sequenza.
</p>
<p class='vspace'>Usando quest'architettura, è possibile separare fisicamente il client dal server, ottimizzando così entrambe le cose. Ottimizzare per un client significa renderlo il più adatto possibile all'utente. Per quanto riguarda il server, invece, ottimizzare vuol dire che funzioni meglio, consumi meno risorse etc.
</p>
<p class='vspace'>L'architettura client - server permette di dividere bene tra i compiti, ed è ben supportata da SQL tramite interrogazioni che vanno dai client ai server, e che tornano risultati dai server ai client. SQL, essendo uno standard, fa sì che queste cose siano portabili ed interoperabili, come volevamo sopra.
</p>
<p class='vspace'>Un <strong>server multithreaded</strong> ha più unità di esecuzione: c'è una coda di ingresso ed una di uscita, ed il <strong>dispatcher</strong> distribuisce le richieste. Se ho un numero di server che varia in funzione del numero di richieste, allora si dice che si ha una <strong>classe di server</strong>.
</p>
<p class='vspace'>Ci sono altre distinzioni nelle architetture client - server: <strong>two-tier</strong> e <strong>three-tier</strong>.
</p>
<p class='vspace'>Nel paradigma <strong>two-tier</strong> ho 2 livelli: il server, ed il client che fa tutto quello che serve per interrogare il server. Si parla quindi di un <strong>thick client</strong>, perché ha molte funzionalità in quanto deve fare tutto lui (a parte poi le operazioni effettive).
</p>
<p class='vspace'>Invece, nel paradigma <strong>three-tier</strong> c'è un <strong>application server</strong> che gestisce le applicazioni. Il client si connette all'application server, il quale fa tutte le robe. Il client deve quindi solo comunicare con l'utente. Ecco perché si dice <strong>thin client</strong>.
</p>
<div class='vspace'></div><h2>BD distribuite</h2>
<p>Si ha una base di dati distribuita quando almeno un client interagisce con server distribuiti. I vantaggi sono:
</p><ul><li>rispeccha il fatto che spesso le aziende sono fisicamente distribuite qua e là
</li><li>è flessibile e modulare
</li><li>è affidabile, se replico i dati
</li></ul><p class='vspace'>Per quanto riguarda i tipi di DBMS usati, le bd distribuite possono essere <strong>omogenee</strong> (quando tutti i DBMS sono uguali) o <strong>eterogenee</strong> (quando uso DBMS di tipo diverso). A seconda delle dimensioni, ho distribuzioni <strong>locali</strong> o <strong>geografiche</strong>.
</p>
<p class='vspace'>Quale che sia la tipologia della bd distribuite, astrattamente essa è una <strong>bd unica</strong>, e come tale va progettata. In pratica è solo l'implementazione fisica che andrà a spantegarsi su più server: nelle fasi di progettazione è un'entità unica.
</p>
<p class='vspace'>Quello che avviene, dopo la progettazione in un pezzo unico, è la <strong>frammentazione</strong>, cioè la partizione di una relazione in diversi frammenti. Ci sono 2 tipi di frammentazione:
</p><ul><li><strong>orizzontale</strong> = a livello di tupla. Ogni server mantiene una <strong>selezione</strong> delle tuple di una certa relazione R, la cui unione restituisce la tupla originaria.
</li><li><strong>verticale</strong> = a livello di attributi, in cui ogni server mantiene solo alcune colonne della R 
</li></ul><p class='vspace'>Le proprietà che devo garantire si chiamano <strong>completezza</strong> e <strong>ricostruibilità</strong>.
</p><ul><li><strong>completezza</strong> = i dati devono esserci, per quanto spantegati
</li><li><strong>ricostruibilità</strong> = devo poter ricostruire la tabella iniziale, con chiavi e tutto
</li></ul><p class='vspace'>Con una <strong>frammentazione orizzontale</strong>, ho che ogni server mantiene alcune tuple. Quindi, i server NON hanno tuple in comune. Nella <strong>frammentazione verticale</strong>, invece, divido per attributi. Però, per garantire le proprietà di cui sopra, è neccessario che ogni frammento verticale si porti dietro la <strong>chiave</strong> della R, altrimenti avrei tuple che non riesco a ricostruire.
</p>
<p class='vspace'>Quindi, facendo l<strong>'unione</strong> dei frammenti orizzontali o il <strong>join</strong> dei frammenti verticali, devo poter ricostruire la R originaria.
</p>
<p class='vspace'>Queste proprietà si cerca di soddisfarle nella fase di <strong>normalizzazione</strong>, di cui avevamo parlato nel corso di Elementi di Basi di Dati, ma su cui non ci eravamo soffermati.
</p>
<p class='vspace'>Una volta che ho individuato i miei frammenti, verticali od orizzontali che siano, devo decidere dove metterli. È lo <strong>schema di allocazione</strong> che mi dice quale frammento è salvato su quale server.
</p>
<p class='vspace'>Questo schema può essere:
</p><ul><li><strong>ridondante</strong>, ovvero ci sono più copie dello stesso frammento su server diversi
</li><li><strong>non ridondante</strong>: una copia di un frammento per server.
</li></ul><p class='vspace'>L'allocazione ridondante è più performante, in generale, perché posso fare riferimento a frammenti locali invece che ripescarli da chissà dove. Il problema è che è difficile da mantenere: infatti, la modifica ad un frammento deve essere replicata su tutti i frammenti in giro per il sistema.
</p>
<p class='vspace'>Teniamo quindi bene a mente che allocazione NON È la stesa cosa di frammentazione. La frammentazione è un'operazione concettuale. L'allocazione è un'operazione fisica che serve per realizzare eventualmente una frammentazione.
</p>
<p class='vspace'>Tenendo presente questa distinzione, posso avere diversi <strong>livelli di trasparenza</strong>, che mi dicono quanto un programma applicativo deve conoscere delle frammentazioni e delle allocazioni interne al sistema.
</p>
<p class='vspace'><strong>Trasparenza di frammentazione</strong>: il programma NON SA NIENTE di frammenti o server, ma vede tutto come una bd unica, e si comporta come tale.
</p>
<p class='vspace'><strong>Trasparenza di allocazione</strong>: il programma conosce i frammenti, ma non sa dove sono allocati fisicamente.
</p>
<p class='vspace'><strong>Trasparenza di linguaggio</strong>: il programma è a conoscenza sia dei frammenti che dei server, e deve gestire il tutto da solo.
</p>
<p class='vspace'><strong>Assenza di trasparenza</strong>: non c'è interoperabilità, nel senso che il linguaggio che si usa è diverso, e quindi ciao.
</p>
<div class='vspace'></div><h2>Classificazione delle interrogazioni</h2>
<p>È una classificazione fatta da IBM, però più o meno vale per tutti.
</p>
<div class='vspace'></div><ul><li><strong>richieste remote</strong> = transazioni read-only, effettuate ad 1 singolo DBMS remoto
</li><li><strong>transazioni remote</strong> = tutti i comandi che voglio ma ad 1 DBMS remoto
</li><li><strong>transazioni distribuite</strong> = tutti i comandi che voglio, ma ad un numero arbitrario di DBMS, però inviando 1 comando per DBMS
</li><li><strong>richieste distribuite</strong> = come sopra, ma 1 comando può riferirsi a più DBMS
</li></ul><p class='vspace'>I problemi insorgono quando il DBMS si trova a dover garantire, come fa con DBMS singoli, le proprietà di isolamento ed atomicità. Deve decidere come dividere la query in sub-query, e scambiare i dati tra di essi. L'ottimizzazione che si fa è quella per la <strong>banda</strong>, perché è quella che costa di più, e poi per uso di CPU.
</p>
<div class='vspace'></div><h3>Serializzabilità globale</h3>
<p>Se ho una query divisa in più sub-query, ognuna inviata ad un server, posso avere che questi server singolarmente hanno uno schedule serializzabile, e quindi tutto ok. Ma è possibile anche che invece questi schedule, visti globalmente, NON siano serializzabili.
</p>
<p class='vspace'>La <strong>serializzabilità globale</strong> è una proprietà che mi dice che occorre uno schedule seriale S equivalente a tutti gli schedule locali S<sub>i</sub> risultanti ad ogni nodo.
</p>
<p class='vspace'>Ciò vuol dire che la proiezione di S sul nodo i deve essere uguale a S<sub>i</sub>.
</p>
<p class='vspace'>Lo posso ottenere utilizzando il 2PL stretto, che è il 2PL base, con in aggiunta la richiesta che posso rilasciare il lock solo dopo il commit o l'abort. Se ogni DBMS implementa il 2PL stretto, ottengo uno schedule globale conflict-serializzabile.
</p>
<p class='vspace'>Un altro modo per ottenere questo effetto è quello di avere un <strong>timestamp</strong> paragonabile per tutti i nodi, ma il problema è proprio avere un orologio distribuito.
</p>
<div class='vspace'></div><h3>Metodo di Lamport</h3>
<div><span class='frame lfloat'><img src='../uploads/Uni/balzo.jpg' alt='' title='' /><br /><strong>Tua sorella e tua cugina balzano in avanti</strong></span></div>
<p>È un metodo per ordinare globalmente tutti gli elementi.
</p>
<p class='vspace'>C'è un timestamp con 2 gruppi di cifre: un gruppo è l'id del nodo, l'altro è quello dell'evento.
</p>
<p class='vspace'>Quando 2 nodi si scambiano messaggi, si devono sincronizzare. Il <strong>ricevente</strong> deve avere un timestamp che sia maggiore o uguale di quello che riceve. In caso sia rimasto indietro, fa un <strong>balzo in avanti</strong> e si sincronizza.
</p>
<div class='vspace'></div><h3>Deadlock distribuiti</h3>
<p>Non paghi di dover gestire il deadlock in <a class='wikilink' href='SistemiOperativi.html'>mille modi diversi</a>, ecco che dobbiamo gestirlo anche in sistemi distribuiti.
</p>
<p class='vspace'>Al solito, quando ho un nodo che attende un altro che attende un altro che attende il primo, ho un deadlock.
</p>
<p class='vspace'>Sistema semplice: metto un time-out. Se ci mette troppo, qualcosa va storto. È in effetti il metodo più usato perché più semplice da implementare.
</p>
<p class='vspace'>Altrimenti, posso tentare di <strong>rilevare e risolvere</strong> i deadlock, attraverso un protocollo asincrono e distribuito, realizzato tramite RPC. C'è sempre il mio grafo di cui devo rilevare la ciclicità, ma in questo caso i nodi sono distribuiti, e devono quindi comunicare tra loro per realizzare un grafo.
</p>
<p class='vspace'>Per evitare di inviare una pletora di messaggi, invio solamente le condizioni di attesa verso il nodo da cui attendo.
</p>
<p class='vspace'>Una <strong>sequenza di attesa</strong> ha più o meno questa faccia:
</p><pre> Ein -&gt; t1,1 -&gt; t2,1 -&gt; Eout
 Ein = evento in ingresso
 t1,1 = transazione 1 sul nodo 1
 t2,1 = transazione 2 sul nodo 1
 Eout = evento in uscita
</pre><p class='vspace'>I nodi inviano verso Eout, cioè il nodo che attendono, solo una condizione di attesa in cui una transazione vecchia sta attendendo una transazione nuova: in termini di id, devo avere che ti &gt; tj.
</p>
<p class='vspace'>Il nodo che riceve la sequenza la deve <strong>combinare</strong> con la sua, e poi inviarla al suo Eout. Nella combinazione, devo collassare tutte le transazioni e far rimanere solamente i nodi, così da poter rilevare il ciclo.
</p>
<p class='vspace'  style='text-align: center; background-color: red; border: 3px dotted yellow; padding: 3px;'><strong>Urge spiegazione migliore e più completa...</strong>
</p>
<div class='vspace'></div><h3>Protocolli per il commit distribuito</h3>
<p>Questa è un'altra gatta da pelare, perché tutti i nodi devono eseguire <strong>insieme</strong> il commit.
</p>
<p class='vspace'>Il protocollo più diffuso è il <strong>two-phase commit</strong>, che NON c'entra con il 2PL, anche se ha lo stesso nome.
</p>
<p class='vspace'>In questo protocollo, la decisione di fare commit o abort è presa da una <strong>terza parte</strong>, il cosiddetto <strong>transaction manager</strong> (TM). Il TM deve gestire i <strong>resource manager</strong> (RM), ovvero i nodi coinvolti nella transazione distribuita.
</p>
<p class='vspace'>Il TM deve mantenere in proprio un log, con questi tre tipi di record:
</p><ul><li>prepare = si sta preparando al commit, e salva la lista dei RM coinvolti
</li><li>global commit / global abort
</li><li>complete = è terminato il 2PC
</li></ul><p class='vspace'>RM parimenti mantiene un log:
</p><ul><li>ready = l'RM ha tutti i lock che gli servono, ed è pronto
</li><li>begin, insert, delete, update = relativi alla transazione in atto
</li></ul><p class='vspace'>Se un RM si dice <strong>ready</strong>, in quel momento <strong>perde la sua autonomia</strong>. Deve attendere che TM gli dica che cosa fare. Entra in una <strong>fase di incertezza</strong> in cui deve attendere che gli altri RM coinvolti comunichino con il TM, e che quindi il TM possa prendere decisioni. Non può fare proprio niente, in questo momento.
</p>
<p class='vspace'>Se invece, per qualche motivo, il RM stabilisce di essere <strong>non ready</strong>, invia comunicazione al TM, e abortisce per conto suo. Infatti, per far abortire una transazione distribuita è sufficiente che 1 RM dica NO. Se è lui stesso a dire NO, ha la certezza che la transazione abortirà, e quindi non attende istruzioni dal TM.
</p>
<p class='vspace'><strong>1<sup>a</sup> fase</strong>:
</p><ul><li>il TM manda il PREPARE a tutti i RM, e attende, impostando un <strong>timeout</strong>
</li><li>ogni RM dice READY o NON-READY, e nel secondo caso fa tutto da solo, come abbiamo appena visto
</li><li>il TM raccoglie le risposte da tutti, e decide per un GLOBAL COMMIT o GLOBAL ABORT
</li></ul><p class='vspace'><strong>2<sup>a</sup> fase</strong>: la decisione del TM deve essere comunicata a tutti
</p><ul><li>il RM scrive nel suo log e ivnia un ACK al TM
</li><li>RM esegue la sua transazione
</li><li>il TM raccoglie gli ACK da tutti. Se un ACK tarda, attende con un nuovo timeout e rimanda la decisione
</li></ul><p class='vspace'>Siccome stiamo parlando di nodi sulla rete, possono accadere diversi spiacevoli accidenti: possono andare down sia i RM che il TM, perdere messaggi, o addirittura cadere la rete intera.
</p>
<div class='vspace'></div><h4>RM down</h4>
<p>Un RM cade, e si presume che prima o poi si risveglierà (se non ci pensa da solo, ci pensa l'admin).
</p>
<p class='vspace'>Deve guardare il suo log. Se ha un <strong>ready</strong>, chiede al TM che cosa fare. Tutte le transazioni dubbie vengono messe in READY, e viene chiesto al TM che cosa fare.
</p>
<div class='vspace'></div><h4>TM down</h4>
<p>Anche qui, il TM si riavvia e guarda il log.
</p>
<p class='vspace'>Se vede un PREPARE, può:
</p><ul><li>mandare un GLOBAL ABORT a tutti i RM coinvolti (come dicevo sopra, nel record PREPARE è salvata la lista di tutti i RM coinvolti), e si prepara alla 2<sup>a</sup> fase
</li><li>ripetere la 1<sup>a</sup> fase
</li></ul><p class='vspace'>Se vede un GLOBAL COMMIT / ABORT, ripete la 2<sup>a</sup> fase.
</p>
<p class='vspace'>Se vede un COMPLETE, non c'è problema, vuol dire che è morto dopo aver messo a posto tutti.
</p>
<div class='vspace'></div><h4>Perdita di messaggi</h4>
<p>Se scade il timeout della fase 1, il TM non ha modo di determinare se i messaggi persi siano stati un PREPARE o un READY. Nel dubbio, invia un GLOBAL ABORT e si riparte.
</p>
<p class='vspace'>Se invece viene perso un GLOBAL oppure un ACK, è il timeout della fase 2 che scade, e quindi viene ripetuta solo lei.
</p>
<div class='vspace'></div><h4>Cade la rete</h4>
<p>Quando cade la rete, vuol dire che essa si partiziona in parti che non comunicano. Se TM e i suoi RM stanno nella stessa partizione, ok, vanno avanti lo stesso. Altrimenti, si abortisce tutto.
</p>
<div class='vspace'></div><h3>Ottimizzazioni</h3>
<p>2PL è molto pesante, perché si scambia un mucchio di messaggi. Si può cercare di risparmiare un po' qua e là.
</p>
<p class='vspace'><strong>Abort presunto</strong>: il TM riceve richieste da RM incerti, e non ha nessuna informazione su di essi: invia un GLOBAL ABORT a tutti (che cosa sono i RM incerti?)
</p>
<p class='vspace'><strong>Read only</strong>: se ho un RM che riceve istruzioni read-only, lo ignoro nella 2<sup>a</sup> fase, che tanto non può dare contributo significativo (non interessa il commit di una lettura).
</p>
<div class='vspace'></div><h3>Varianti</h3>
<p>C'è il lock distribuito a <strong>4 fasi</strong>, in cui c'è un TM di backup. Il TM "normale" comunica tutte le sue decisioni PRIMA al TM di backup, così se va giù c'è il backup che comunque ne sa qualcosa. Ma è pesante...
</p>
<p class='vspace'>Poi c'è quello a <strong>3 fasi</strong> in cui un nodo fa il sostituto del TM, se quest'ultimo cade. Il problema è che la finestra di incertezza si allunga. Il problema con sto sistema è che se la rete si partiziona, ed ogni partizione elegge il suo TM, è l'anarchia. Ecco perché è poco usato.
</p>
<p class='vspace'><a class='wikilink' href='BDComplementi.html'>Torna alla pagina di BDC</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/BDC21aprile2008)</span></div>
  </div>
</body>
</html>
