<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Sistemi Operativi - Strutture dei sistemi distribuiti</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='SO-StruttureDeiSistemiDistribuiti.html' title='Sistemi Operativi - Strutture dei sistemi distribuiti'>Sistemi Operativi - Strutture dei sistemi distribuiti</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
<a class='wikilink' href='SistemiOperativi.html'>Torna alla pagina di Sistemi Operativi</a>
</p><hr />
<div class='vspace'></div><pre  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'> <strong>:: Appunti 2.0 ::</strong>
</pre><p class='vspace'  style='text-align: center;'><span  style='background-color: #d9e4f2; font-size: 11pt; padding: 4px; padding-left: 50px; padding-right: 50px;'>Strutture dei sistemi distribuiti</span>
</p>
<div class='vspace'></div><h2>Concetti di base</h2>
<p>Un <strong>sistema distribuito</strong> è un insieme di sistemi di elaborazione che non condividono memorie o orologi e che sono connessi tra loro mediante una rete di comunicazione. Ognuno dei singoli sistemi può essere chiamato con molti nomi, ad esempio <strong>host</strong> o <strong>macchina</strong>, e mentre le sue risorse interne sono definite <em>locali</em>, quelle che può raggiungere attraverso la rete sono dette <em>remote</em>.
</p>
<p class='vspace'>Obiettivo dei sistemi distribuiti è fornire un ambiente efficace e conveniente per la condivisione di risorse tra macchine diverse.
</p>
<div class='vspace'></div><h3>Vantaggi dei sistemi distribuiti</h3>
<p>I principali motivi per costruire sistemi distribuiti sono:
</p><ul><li><em>condivisione delle risorse</em>: ogni utente è in grado di usare le risorse (file, periferiche, potenza di calcolo) disponibili su macchine remote
</li><li><em>velocità di calcolo</em>: può aumentare se l'elaborazione viene suddivisa ed eseguita in modo concorrente su più host. Si può condividere anche il carico di lavoro, distribuendolo su più macchine così da evitare sovraccarichi
</li><li><em>affidabilità</em>: il guasto di un host generalmente non compromette il funzionamento dell'intero sistema. Certo deve essere progettato con intelligenza, con ridondanze adeguate sia hardware che dei dati
</li><li><em>comunicazione</em>: molto simile a quella che avviene fra i processi all'interno di un singolo sistema, così che possa essere facilmente estesa all'ambiente distribuito
</li><li><em>scalabilità</em>: capacità del sistema di adattarsi al variare del carico di servizio
</li></ul><p class='vspace'>Tutti questi fattori hanno fatto sì che le industrie si orientassero verso i sistemi distribuiti e allo stesso tempo verso un <em>downsizing</em> dei sistemi di calcolo, dal momento che reti di macchine a medio-basse prestazioni hanno nell'insieme ottime funzionalità e costi ridotti.
</p>
<div class='vspace'></div><h3>Tipi di sistemi distribuiti</h3>
<p>Esistono due grandi categorie di sistemi orientati alle reti e li vedremo nei prossimi capitoli.
</p>
<div class='vspace'></div><h4>Sistemi operativi di rete</h4>
<p>Un <strong>sistema operativo di rete</strong> fornisce un ambiente in cui gli utenti, che sono consapevoli della molteplicità delle macchine, possono accedere a risorse remote.
</p>
<p class='vspace'>Tre importanti funzioni di questo sistema sono:
</p><ul><li><em>sessioni di lavoro remote</em>, ovvero la possibilità per un utente di collegarsi ad un'altra macchina in remoto (previa login) e interagire con essa come se fosse in locale. E' ciò che fa il programma <code class='escaped'>telnet</code> per Internet
</li><li><em>trasferimento remoto di file</em> tra host, con una copia esplicita dal file system remoto a quello locale. In internet ciò è reso possibile dal protocollo <code class='escaped'>ftp</code>
</li><li>attivare procedure remote attraverso le <em>Remote Procedure Calls</em> (<em>RPC</em>)
</li></ul><p class='vspace'>Notare che ogni computer <em>conserva il proprio file system locale</em> e (molto importante) la posizione dei file <em>non è trasparente</em> agli utenti, che devono sapere esattamente dove si trovano. Abbiamo già detto infatti che non avviene una vera condivisione di dati: l'utente può solo copiarli da un host all'altro.
</p>
<div class='vspace'></div><h4>Sistemi operativi distribuiti</h4>
<p>In un <strong>sistema operativo distribuito</strong> gli utenti accedono alle risorse remote nello stesso modo in cui accedono a quelle locali, e la migrazione dei processi e dei dati da un host all'altro avviene sotto il controllo del sistema operativo distribuito.
</p>
<p class='vspace'>La <em>migrazione dei dati</em> può avvenire in due modi:
</p><ol><li>quando un utente richiede un file su una macchina remota, questo viene interamente trasferito così da potervi accedere in locale. A elaborazione compiuta, se è stato modificato, viene interamente ricopiato nella macchina di origine
</li><li>simile al precedente, ma a differenza dell'intero file vengono trasferite solo le parti effettivamente necessarie al processo in quel preciso momento
</li></ol><p>In entrambi i metodi il sistema non si limita a trasferire, ma fa anche le traduzioni opportune se le rappresentazioni dei dati (big endian, little endian) non sono compatibili.<br />Qual è la tecnica migliore? Dipende dalle porzioni di file che vengono mediamente richieste. 
</p>
<p class='vspace'>In alcuni casi è preferibile <em>trasferire la computazione</em> piuttosto che i dati, scelta particolarmente saggia se il tempo di trasferimento è più lungo del tempo di esecuzione di un comando remoto. Il tutto può essere realizzato con una RPC o con l'attivazione di un processo remoto per mezzo di scambio di messaggi.
</p>
<p class='vspace'>Una logica estensione della <em>migrazione della computazione</em> è quella dei processi, dove l'esecuzione di questi ultimi non avviene interamente nell'host in cui sono stati attivati. Ci sono due tecniche per spostarli, una che prevede la migrazione in modo tatalmente trasparente all'utente (più rapida su sistemi omogenei), l'altra che invece permette o richiede le modalità di migrazione (più portabile e configurabile). Alcuni motivi per la migrazione dei processi sono il bilanciamento del carico, una maggiore velocità di calcolo, maggiore compatibilità dell'hardware o del software, accesso ai dati, ecc.
</p>
<div class='vspace'></div><h2>Topologia</h2>
<p>I vari host in un sistema distribuito possono essere connessi fisicamente in molti modi diversi, e le configurazioni ottenute si possono valutare in base al costo dell'installazione e della comunicazione (tempo + soldi) e dalla disponibilità, ovvero dall'ampiezza della zona in cui si può accedere ai dati malgrado il guasto di alcuni collegamenti o macchine.
</p>
<p class='vspace'>Le reti completamente connesse sono molto performanti e affidabili, ma hanno costi d'installazione spesso insostenibili; gli si preferisce quelle parzialmente connesse, nelle quali vanno però fornite informazioni d'instradamento a quegli host che non sono direttamente collegati.
</p>
<p class='vspace'>La scelta della configurazione migliore dipende dal sistema che si vuole ottenere e dalla situazione ambientale, non esiste una topologia migliore in assoluto.
</p>
<div class='vspace'></div><h2>Comunicazione</h2>
<h3>Attribuzione e risoluzione dei nomi</h3>
<p>Per identificare in modo certo i siti di una rete e i loro processi è necessario dare loro un nome univoco. I processi su sistemi remoti vengono usualmente identificati dalla coppia <code class='escaped'>&lt;nome host, identificatore&gt;</code>, dove <code class='escaped'>nome host</code> è unico nella rete e l'<code class='escaped'>identificatore</code> è il comune <em>id</em> del processo.
</p>
<p class='vspace'>La risoluzione dei nomi deve tradurre il nome di una macchina in un valore numerico che descriva il sistema di destinazione all'hardware della rete. Ciò avviene o per mezzo di una lista mantenuta in locale da ogni host che riporta tutte le corrispondenze tra nomi e indirizzi (soluzione onerosa), o distribuendo tali informazioni tra i computer della rete ed utilizzando un protocollo per la risoluzione. Questo secondo sistema è quello del <em>server dei nomi del dominio</em> (<em>DNS</em>), reso nel tempo sempre più efficiente e sicuro grazie a numerosi raffinamenti.
</p>
<div class='vspace'></div><h3>Strategie di instradamento</h3>
<p>Se in un sistema distribuito esistono più percorsi per collegare due host, allora ci sono diverse opzioni di instradamento. Ogni sito ha una <em>tabella di instradamento</em> mantenuta aggiornata che indica i vari percorsi alternativi per la trasmissione di un messaggio, e che può contenere informazioni aggiuntive come velocità e costi.
</p>
<p class='vspace'>Sono tre gli schemi di instradamento più comuni:
</p><ul><li><strong>instradamento fisso</strong>: un percorso tra due macchine viene determinato a priori e non cambia a meno di guasti
</li><li><strong>instradamento virtuale</strong>: viene definito un percorso tra due host valido per tutta la durata di una sessione
</li><li><strong>instradamento dinamico</strong>: il percorso da impiegare per inviare un messaggio viene scelto al momento dell'invio
</li></ul><p class='vspace'>L'instradamento dinamico è il più complicato da organizzare e gestire, ma è il più efficace in ambienti complessi data l'adattabilità alle variazioni di carico e di gestione dei guasti.
</p>
<p class='vspace'>Il <strong>gateway</strong> è un dispositivo hardware dedicato che collega la rete locale ad altre reti, gestendo l'eventuale cambiamento di protocollo di comunicazione. Gli host si collegano al gateway con instradamento statico, mentre quest'ultimo si collega alla rete con schema dinamico. Un altro dispositivo molto importante in una rete è il <strong>router</strong>, responsabile dell'instradamento dei messaggi tra due reti.
</p>
<div class='vspace'></div><h3>Strategie di pacchetto</h3>
<p>I messaggi di per sé non hanno una lunghezza standard, ma per semplificare la progettazione del sistema si preferisce realizzare comunicazioni con messaggi a dimensione fissa chiamati <strong>pacchetti</strong> (o <em>frame</em> o <em>datagram</em>). La comunicazione implementata a pacchetti può avvenire mediante messaggi senza connessione inaffidabili (senza garanzia di ricezione, esempio l'UDP) o affidabili (esempio TCP).
</p>
<div class='vspace'></div><h3>Strategie di connessione</h3>
<p>Una volta che i messaggi sono in grado di arrivare a destinazione i processi possono istituire delle <strong>sessioni di comunicazione</strong> per scambiarsi le informazioni. Ne vengono comunemente usate di tre tipi:
</p><ul><li><strong>commutazione di circuito</strong>, con un collegamento fisico permanente che perdura per tutta la comunicazione e che non può essere usato da altri processi. Richiede alti tempi di attivazione e può sprecare molta larghezza di banda
</li><li><strong>commutazione di messaggi</strong>, in cui si stabilisce un collegamento temporaneo tra due processi che termina col completamento del trasferimento. I collegamenti fisici vengono allocati dinamicamente per brevi periodi in base alle necessità
</li><li><strong>commutazione di pacchetto</strong>, dove ciascun pacchetto di un messaggio è inviato separatamente su una connessione attivata dinamicamente. E' la tecnica che fa il miglior uso della larghezza di banda e per questo è tra le più utilizzate. Tuttavia ha un alto overhead per ogni messaggio, dato che deve contenere diverse informazioni per essere suddiviso in pacchetti e correttamente riassemblato
</li></ul><div class='vspace'></div><h3>Gestione dei conflitti</h3>
<p>Le <strong>collisioni</strong> in un sistema distribuito avvengono quando a un host arrivano contemporaneamente due messaggi, che diventano entrambi indecifrabili. Esistono molte tecniche per evitarlo, tra cui ricordiamo:
</p><ul><li>il rilevamento della portante ad accesso multiplo (CSMA) unito al rilevamento delle collisioni (CD). In breve, prima di trasmettere un messaggio l'host verifica che la linea di comunicazione non sia usata da altri; se si rileva una collisione si interrompe la trasmissione e la si ritenta dopo un intervallo di tempo casuale
</li><li>passaggio di token per imporre la turnazione, adoperato nei sistemi con struttura ad anello. La macchina può inviare un messaggio solo se è in possesso del token, che viene passato tra i vari host a intervalli regolari
</li></ul><div class='vspace'></div><h2>Protocolli di comunicazione</h2>
<p>Nella progettazione di una rete di comunicazione i fattori critici da tenere in considerazione sono le <em>comunicazioni asincrone</em>, le <em>interazioni tra ambienti non omogenei</em> e la <em>probabilità di avere errori</em>. L'obiettivo che ci si prefigge è dunque creare un ambiente omogeneo di comunicazione che la astragga e virtualizzi così da semplificare la progettazione e avere una gestione efficiente del sistema. <br />La soluzione è l'adozione di protocolli di comunicazione da applicare a strati distinti del sistema, utilizzati un po' come se fossero i driver della rete. La comunicazione avviene ovviamente solo tra strati equivalenti.
</p>
<p class='vspace'>Il modello teorico standard è l'ISO/OSI, che divide il sistema in:
</p><ul><li><strong>strato fisico</strong>, responsabile della definizione dei dettagli elettromeccanici della trasmissione fisica. Implementato nell'hardware
</li><li><strong>strato di collegamento dei dati</strong>, che gestisce la trasmissione dei pacchetti e rileva e corregge gli errori
</li><li><strong>strato di rete</strong>, che si occupa delle connessioni e dell'instradamento dei pacchetti
</li><li><strong>strato di trasporto</strong>, che partiziona e mantiene ordinati i pacchetti di un messaggio, ne controlla il flusso e gestisce gli errori
</li><li><strong>strato di sessione</strong>, che realizza le sessioni e i protocolli di comunicazione tra processi
</li><li><strong>strato di presentazione</strong>, che risolve le differenze di formato tra le varie macchine
</li><li><strong>strato di applicazione</strong>, responsabile dell'interazione con gli utenti
</li></ul><p class='vspace'>Questo è un buon modello, ma storicamente si è preferito adottarne uno più semplice ed efficiente: il <strong>TCP/IP</strong>, detto anche <em>modello reale</em>. Il protocollo TCP corrisponde allo strato di trasporto, è orientato alle connessioni ed è affidabile (l'opposto dell'UDP). Il protocollo IP è invece responsabile dell'instradamento dei pacchetti attraverso Internet.
</p>
<div class='vspace'></div><h2>Robustezza</h2>
<p>In un sistema distribuito sono molti i tipi di guasti in cui si può incorrere, ma per garantire la <strong>robustezza</strong> bisogna comunque individuarli, rinconfigurare il sistema per poter continuare la computazione e infine recuperare la configurazione iniziale a guasto riparato.
</p>
<div class='vspace'></div><h3>Individuazione dei guasti</h3>
<p>In un ambiente senza memoria condivisa è di solito impossibile distinguere le tipologie di guasto, se hardware o software ad esempio, ma ci si deve accontentare di rilevarli (che è già tanto). Tra le tecniche di rilevamento le più utilizzate sono il <em>monitoraggio periodico con handshaking</em>, l'impostazione di un <em>time-out</em> (superato il quale viene sollevato un errore) e la <em>computazione duplicata con confronto dei risultati</em> (che oltre a rilevare il guasto offre una controprova della correttezza dei risultati).
</p>
<div class='vspace'></div><h3>Riconfigurazione del sistema</h3>
<p>Una volta rilevato che un certo host è guasto, bisogna anzitutto aggiornare tutte le tabelle di instradamento della rete affinché la comunicazione non passi da lì. Bisogna poi fare in modo che siano tutti informati del fatto che i servizi erogati da quella macchina non sono temporaneamente disponibili, e anzi bisogna cercare di far migrare tali servizi su altri siti.
</p>
<div class='vspace'></div><h3>Recupero di un guasto</h3>
<p>A guasto riparato la macchina deve essere reintegrata nel sistema in modo che gli altri host possano essere informati (tramite handshaking) del suo ripristino. Le tabelle interne della macchina verranno quindi ripristinate e aggiornate, e gli verranno recapitati i messaggi pendenti.
</p>
<div class='vspace'></div><h2>Problemi progettuali</h2>
<p>L'obiettivo principale di un progettista di sistemi distribuiti è renderli del tutto trasparenti agli utenti, dando l'illusione che stiano operando su un sistema centralizzato convenzionale.
</p>
<p class='vspace'>Altri aspetti che vanno tenuti in considerazione sono:
</p><ul><li>la <em>mobilità dell'utente</em>, che non deve essere obbligato a collegarsi a un unico host specifico
</li><li>la <em>tolleranza ai guasti</em>, ovvero il sistema dovrebbe continuare a funzionare anche in caso di guasto - anche se con funzionalità in meno - fino alla riparazione
</li><li>la <em>scalabilità</em>, ovvero la capacità del sistema di adattarsi all'aumento del carico di servizio
</li></ul><div class='vspace'></div><hr />
<p><a class='wikilink' href='SistemiOperativi.html'>Torna alla pagina di Sistemi Operativi</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/SO-StruttureDeiSistemiDistribuiti)</span></div>
  </div>
</body>
</html>
