<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
 <title>Swappa : Uni / Ingegneria del Software - Appunti del 17 Marzo 2009</title>
 <meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1' />
 <meta http-equiv='Content-Language' content='en' />
 <meta http-equiv='Content-Style-Type' content='text/css' />
 <meta http-equiv="imagetoolbar" content="no" />
 <meta name='MSSmartTagsPreventParsing' content='true' />
 <!--HeaderText--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.progress-bar {
	display: block;
	background: transparent; 
	width: 520px;
	font-size: 1px; /* for IE */
	margin: 2px 0;
}

.progress-bar .pb1, .progress-bar .pb2, .progress-bar .pb3, .progress-bar .pb4 {
	display: block; 
	background: #fff; 
	border-left:  1px solid #999; 
	border-right: 1px solid #999;

	overflow: hidden; 
	height: 1px; 
}
.progress-bar .pb1 { margin: 0 4px; background: #999;}
.progress-bar .pb2 { margin: 0 2px; border-width: 0 2px; }
.progress-bar .pb3 { margin: 0 1px; }
.progress-bar .pb4 { height: 11px; padding: 0 3px; }
.progress-bar .pb5 { display: block; background: #eeeeef; overflow:hidden; }

.progress-bar .bar {
	display: block;
	background: #a5bbd8;
	height: 11px;
	padding: 0;
}
.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
  div.faqtoc div.faq * { display:none; }
  div.faqtoc div.faq p.question 
    { display:block; font-weight:normal; margin:0.5em 0 0.5em 20px; line-height:normal; }
  div.faqtoc div.faq p.question * { display:inline; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>
  <link rel='stylesheet' href='../pub/wsplus/wsplus.css' 
    type='text/css' />
  <!--[if IE]><style type='text/css' media='screen'>
    body { behavior:url('http://www.swappa.it/wiki/pub/wsplus/csshover.htc'); }
    .rollover * { visibility: visible; }
  </style><![endif]-->
<script type='text/javascript' src='../pub/syntaxlove/scripts/shCore.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCSharp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushCpp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushJava.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPerl.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPhp.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushPython.js'></script><script type='text/javascript' src='../pub/syntaxlove/scripts/shBrushRuby.js'></script> <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shCore.css'/>
  <link type='text/css' rel='stylesheet' href='../pub/syntaxlove/css/shThemeDefault.css'/>
  <script type='text/javascript'>
  	SyntaxHighlighter.config.clipboardSwf = 'http://www.swappa.it/wiki/pub/syntaxlove/scripts/clipboard.swf';
  	SyntaxHighlighter.all();
  </script>  <meta name='robots' content='noindex,nofollow' />

 <style type='text/css'><!--

/* Default Fonts */
body { font-family: Verdana,Arial,Helvetica,sans-serif; }
body, td, th { color:#000000; }
body, td, th { font-size: 10pt; }
small { font-size:0.85em; }
code { white-space: nowrap; }
h1, h2, h3, h4, h5 { margin-top:1em; margin-bottom:0.6em; }
h1 { font-size: 1.9em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.25em; }
h4 { font-size: 1.06em; }
h5 { font-size: 1.0em; }
ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }

/* Misc. */
body { width:auto; background-color:#ffffff; margin:0px; padding:0.5em; }
img { border-width: 0px; }
.indent { margin-left:30px; }
.outdent { margin-left:30px; text-indent:-30px; }
.vspace { margin-top:1.33em; }

/* Links */
a:link { color:#333333; font-weight:normal; text-decoration:underline; }
a:visited { color:#333333; font-weight:normal; text-decoration:underline; }
a.wikilink:hover { color: #333333; text-decoration:underline; }
a.createlink { text-decoration:none; position:relative; top:-0.5em; font-weight:bold; font-size:smaller; border-bottom:none; }
a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
a.varlink { text-decoration:none; }
.apprlink { font-size:smaller; }

/* Print View Page Header */
#printhead { font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }
#printhead a, #printhead a:visited { font-weight:bold; text-decoration:none; }
#cc { float:right; font-size:11pt; border-bottom:2px solid #a0a0a0; margin-bottom:1em; }

/* Print View Page Footer */
#printfoot { font-family: Arial,Helvetica,Geneva,sans-serif; margin-top:1em; border-top:2px solid #a0a0a0; font-size:7pt; }
  
 --></style>
</head>
<body>
  <div id='printhead'>
    <a href='../index.html' title='Swappa Home'>Swappa</a> :
    <a href='http://www.swappa.it/wiki/Uni' title='Uni Home'>Uni</a> /
    <a href='IDS-17Marzo.html' title='Ingegneria del Software - Appunti del 17 Marzo 2009'>Ingegneria del Software - Appunti del 17 Marzo 2009</a>
    <div id='cc'>
	<a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.5/it/">
	<img alt="Creative Commons License" style="border-width:0" height="15" width="80" src="http://i.creativecommons.org/l/by-nc-sa/2.5/it/80x15.png" />
	</a>
    </div>
  </div>
  
<!--PageText-->
<div id='wikitext'>
<p>
</p><pre> <a class='wikilink' href='IngegneriaDelSoftware.html'>Torna alla pagina di Ingegneria del Software</a>
</pre><p class='vspace'  style='text-align: center; background-color: #ffe4c4; border: 2px solid #cccccc; font-size: 13pt; padding: 5px;'><strong>:: Ingegneria del Software - Appunti del 17 Marzo 2009 ::</strong>
</p>
<div class='vspace'></div><h2>Automi</h2>
<p>Dopo aver visto nella lezione precedente che cosa sono gli automi, partiamo dicendo che gli automi vanno bene, a differenza dei CdU, per indicare la <em>temporizzazione</em> degli eventi, cioè dire quando una cosa accade nel corso del tempo.
</p>
<p class='vspace'>Possiamo indicare gli automi anche con la sigla <strong>MSF</strong>, o <strong>FSM</strong> all'inglese, che significa <strong>macchina a stati finiti</strong>. Un automa è infatti una macchina che, una volta fatta "partire", va avanti da sola a seconda di quello che le viene passato in input. Il concetto di "stati finiti" ha a che fare con la rappresentabilità algoritmica dell'automa stesso: un numero infinito di stati non è rappresentabile da nessuno, né con un disegno, né da un computer.
</p>
<div class='vspace'></div><h3>Stimoli e risposte</h3>
<p>Nella sua forma più basilare, un automa reagisce con un output a certi input. La funzione di transizione ha quindi la forma <em>f: I -&gt; O</em>.
</p>
<p class='vspace'>Per dare qualche definizione, diciamo che
</p><ul><li>una <strong>parola</strong> sull'alfabeto di <strong>input</strong> è una sequenza di simboli tratti da quelli che la macchina riconosce come input
</li><li>una <strong>parola</strong> sull'alfabeto di <strong>output</strong> è una sequenza di simboli tratti da quelli che la macchina produce come output
</li></ul><p class='vspace'>La funzione di transizione definita qualche riga sopra ci dice una cosa importante: l'output dipende <strong>solo</strong> dall'input, e da nient'altro. Questo significa che la macchina non ha nessuna nozione di quello che è successo prima, perché non ha nessun modo per tenerne traccia: è come picchiare col martelletto sul ginocchio, questo salta, poi torna in attesa, se picchio ancora esso salta ancora e così via.
</p>
<p class='vspace'>In altre parole, il modello di FSM così definita è <strong>senza memoria</strong>, ovvero <strong>stateless</strong>. Si capisce subito che una FSM fatta in questo modo è limitante, perché non può modellare tantissimi problemi che invece richiedono una risposta diversa allo stesso stimolo a seconda dello stato in cui si trova in quel momento la macchina stessa.
</p>
<p class='vspace'>Quindi, se voglio che la macchina risponda ad un certo input anche in funzione dello stato in cui si trova, devo avere un'altra categoria di funzioni che tenga conto anche di questo:
</p><pre> f(I,S) -&gt; O
 g(I,S) -&gt; S
</pre><p>ovvero:
</p><ul><li>la funzione <strong>f(I,S) -&gt; O</strong> produce un output a seconda dell'input ricevuto e dello stato attuale
</li><li>la funzione <strong>g(I,S) -&gt; S</strong> mette la macchina in uno stato a seconda dell'input ricevuto e dello stato attuale
</li></ul><p class='vspace'>Una macchina in qui ho definite entrambe queste funzioni è detta <strong>stateful</strong>.
</p>
<p class='vspace'>Esiste un teorema matematico tramite il quale si può dimostrare che una macchina con output è rappresentabile in modo perfettamente equivalente con una macchina senza output.<br />Intuitivamente, ciò lo si può ottenere immaginando di "incapsulare" l'output negli stati, ovvero mettere nella descrizione degli stati anche l'output che la macchina dovrebbe produrre sotto quelle condizioni. Certo, il numero di stati in questo modo esploderebbe, ma preserverei l'equivalenza.
</p>
<p class='vspace'>A noi non interessa tanto l'equivalenza in sé tra macchine con output e macchine senza output. La cosa veramente interessante è che questa proprietà è dimostrabile <strong>matematicamente</strong>. Infatti, gli automi sono un linguaggio dotato di semantica, e quindi hanno regole matematiche ben precise e non ambigue che mappano il dominio in un codominio. Il poter maneggiare gli automi in modo matematico ci permette proprio di poter inferire delle proprietà che essi hanno tramite il calcolo, e quindi in modo certo e indiscutibile.
</p>
<p class='vspace'>Questa è la grande differenza tra i linguaggi dotati di semantica e quelli che ne sono sprovvisti. Senza semantica non sono in grado di applicare ragionamenti matematici relativi al linguaggio, mentre al contrario la semantica mi permette di adoperare la matematica a questo fine.
</p>
<div class='vspace'></div><h3>Il problema della memoria</h3>
<p>Uno stato rappresenta uno stato di esistenza dell'automa in un dato istante. Le funzioni di transizione che mappano una combinazione SxI in uno stato finale S ci permettono di modellare il passaggio da uno stato all'altro della nostra macchina.
</p>
<p class='vspace'>Come abbiamo detto sopra, ciò ci permette di rappresentare la <strong>memoria</strong> della nostra macchina: se mi trovo in un certo stato, è perché ho avuto una certa <strong>storia</strong> alle mie spalle, e pertanto so reagire di conseguenza.
</p>
<p class='vspace'>Si tratta sicuramente di un bel vantaggio rispetto agli automi FSM più semplici, ma c'è un problema essenziale che salta subito all'occhio, ed è dovuto al fatto che la memoria della macchina viene rappresentata dagli stati.
</p>
<p class='vspace'>Supponiamo di avere un magazzino che può contenere fino a dieci oggetti. Posso modellarlo con un automa con una combinazione di 11 stati, ciascuno rappresentante la condizione del magazzino in un dato istante: vuoto, 1 oggetto, 2 oggetti... 10 oggetti.<br />Se voglio raddoppiare il numero degli oggetti, devo raddoppiare il numero degli stati. Ma se, come nel caso della memoria del computer, il limite al numero degli oggetti è altissimo, dovrei allora avere un numero altissimo di stati, e ciò è poco praticabile.
</p>
<p class='vspace'>Facciamo ancora un esempio. Il nostro magazzino ha capacità massima di 10 pezzi. Però, se nel caso sopra avevo tacitamente supposto che potevo inserire ed estrarre un solo pezzo alla volta, ora voglio poter inserire o togliere 1, 2 o 3 pezzi alla volta.<br />Immaginiamo di essere nello stato che rappresenta il magazzino con 5 oggetti dentro. Devono esserci:
</p><ul><li>una freccia che porta allo stato 6, quando inserisco un oggetto
</li><li>una freccia che porta allo stato 7, quando inserisco due oggetti
</li><li>una freccia che porta allo stato 8, quando inserisco tre oggetti
</li><li>una freccia che porta allo stato 4, quando tolgo un oggetto
</li></ul><p>etc. etc.
</p>
<p class='vspace'>In caso di memoria molto ampia e di capacità ampie di gestione della stessa, il numero di transizioni esplode in modo incontrollabile.
</p>
<p class='vspace'>D'altronde, già il nome stesso della macchina (macchina a <strong>stati finiti</strong>) mi dice che non posso avere a che fare con un numero infinito di stati.
</p>
<p class='vspace'>La soluzione esiste, e consiste nel costruire, separato dal mio automa, un qualche strumento che mi permetta di gestire la memoria. Quanto questa soluzione sia comoda, non si sa.
</p>
<div class='vspace'></div><h3>Il problema della sincronizzazione</h3>
<p>Come già visto <a class='wikilink' href='LPSFSM.html'>qui</a>, c'è un grosso problema relativo alla sincronizzazione di due automi separati.
</p>
<p class='vspace'>Nel caso in cui io voglia far collaborare due sistemi diversi, ogni macchina deve avere nozione di quello che le altre macchine hanno fatto per poter prendere delle decisioni.
</p>
<p class='vspace'>La matematica ci può venire in aiuto, tramite l'operazione di <strong>fusione</strong> tra due automi diversi. Si tratta di una combinazione condizionata tra tutti gli stati e gli input di un automa, con tutti gli stati e gli input dell'altro automa. Purtroppo, già sappiamo che il prezzo di questa operazione, pure ottenibile in modo automatico, è l'esplosione del numero degli stati.
</p>
<p class='vspace'>La soluzione a questo problema c'è, ma consiste nell'abbandonare gli automi per dedicarci alle <strong>reti di Petri</strong>, che vedremo nella prossima lezione. Possiamo però anticipare alcune cose:
</p><ul><li>le reti di Petri sono molto più espressive, ma proprio per questo più ardue da gestire matematicamente
</li><li>in <a class='wikilink' href='LPSUML.html'>questa pagina</a>, alla voce <strong>Comunicazione tra macchine</strong>, ci sono alcuni indizi sul funzionamento delle reti di Petri nella parte relativa alla sincronizzazione tra macchine differenti, e potrebbe essere utile darci un'occhiata.
</li></ul><div class='vspace'></div><h2>Il lemma di espansione</h2>
<p>Questo argomento è stato trattato in una lezione successiva, ma riguarda gli automi, e permette di comprenderne meglio alcune caratteristiche.
</p>
<p class='vspace'>Il <strong>lemma di espansione</strong> mi dice (in modo informale) che, se ho dimostrato per <strong>enumerazione</strong> che per arrivare ad un certo stato mi occorre una stringa di una certa lunghezza, allora questa proprietà sarà vera sempre, perché tutte le altre stringhe saranno più lunghe.
</p>
<p class='vspace'>Qui ci andrebbe un disegnino...
</p>
<p class='vspace'>La cosa interessante è che ho dimostrato che occorre almeno una <strong>a</strong> per andare fino allo stato <strong>KO</strong>, e l'ho dimostrato per enumerazione, cioè contando a mano i possibili percorsi. Non ce ne sono altri, e quindi sono felice.
</p>
<p class='vspace'>In quest'altro automa (disegnino) invece c'è un ciclo. L'enumerazione totale è impossibile, perché i cicli sono potenzialmente infiniti. Ma se lo dimostro per una stringa per enumerazione, e so che tutte le altre stringhe sono per forza di cose più lunghe, allora per il lemma di espansione posso inferire che si tratti di una proprietà dell'automa.
</p>
<div class='vspace'></div><hr />
<p><a class='wikilink' href='IngegneriaDelSoftware.html'>Torna alla pagina di Ingegneria del Software</a>
</p>
</div>

  <div id='printfoot'>
    <div class='printview'>(Printable View of <span style='white-space:nowrap;'>http://www.swappa.it/wiki/Uni/IDS-17Marzo)</span></div>
  </div>
</body>
</html>
